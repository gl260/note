这是网上找的一些面试题

## 面试一

### 介绍一下BFC

* BFC :  block formatting context  块级格式化上下文 --- **是用来决定块级盒子是如何排布的**
  * BFC是一个独立的布局环境 相当于是一个容器 在其中按照一定的规则对块级元素进行摆放 ,并且不会影响其他的布局环境中的盒子,如果一个元素触发BFC则BFC中的元素布局不受外界的影响

* 特点
  - 在BFC中,box会在垂直方向上一个挨着一个的排布
  - 垂直方向的间距由margin属性决定
  - 在**同一个BFC中**，相邻两个box之间的margin会折叠
  - 在BFC中，每个元素的左边缘是紧挨着包含块的左边缘的
* 作用
  - 可以利用BFC处理margin的折叠问题,浮动的高度塌陷问题
* 创建BFC的条件
  - 根元素（<html>）
  - float left/right
  - position absolute/fixed
  - overflow: 除visible
  - display: inline-block等
* 块级元素在标椎流里面都是在BFC中布局的---->这是因为根元素<html>会创建BFC



### display属性有哪些值

* block / inline / inline-block / none / flex / grid



### 讲一下flex弹性布局, 怎么改变布局下元素的顺序？

* 弹性盒子是一种用于按行或按列布局元素的一维布局方法
* Flex 布局有两根轴线，分别为主轴和交叉轴
  * 主轴由 flex-direction 定义，另⼀根轴垂直于它。



* 有两种方式改变布局下的元素顺序

  * 方式一:  给子元素设置order

    ```css
    .port-item:nth-child(1) {
      order: 2;
    }
    .port-item:nth-child(2) {
      order: 1;
    }
    .port-item:nth-child(3) {
      order: 4;
    }
    .port-item:nth-child(4) {
      order: 3;
    }
    ```

  * 方式二: 通过flex-direction设置设置主轴的方向, 也可以改变元素顺序

    ```css
    .column-reverse-item {
      height: 116px;
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      flex-direction: column-reverse;
    }
    ```



### 讲一下ES6的常用语法

* let/const声明变量
* 函数的默认参数
* 展开语法 -- ⼀种浅拷贝
* 函数的剩余参数
* 模版字符串
* 解构赋值
* 使用class定义类
* 箭头函数
* forEach / map
* Promise
* 新增symbol数据类型
* Set WeakSet Map WeakMap
* 数组的includes方法
* async / await
* BigInt
* 可选链 ?.
* 等等



### for...in 和 for...of的区别

* for in: 我们一般用来遍历对象的, 遍历的是对象的key值

  * for… in 会遍历对象的整个原型链，性能相对来说是比较差的, 不推荐使用

* for of: 只能遍历可迭代对象, 遍历的是值: String、Array、Map、Set、arguments对象、NodeList集合

  * 而for … of 不会遍历原型链
  



### 改变this指向的方法有哪些

* call / apply / bind

  ```js
  greet.call(person, "北京", "中国") // 以多参数的形式
  
  greet.apply(person, ["北京", "中国"]) // 以数组的形式
  
  // 与 call 和 apply 不同，bind 不会立即执行函数，而是返回一个新的函数，你可以稍后执行它
  var bar = foo.bind(obj);
  bar(); // this --> obj
  // 这里是独立函数的调用,为什么this不是指向window
  // 这里设计到规则优先级问题,这里的bind绑定的优先级 > 默认绑定
  ```

* 区别

  - call、apply和bind都可以改变函数的this指向 第⼀个参数都是this要指向的对象
  - 都可以后续为函数传参 apply是将参数并成⼀个数组，call和bind是将参数依次列出
  - call、apply都是直接调⽤，bind生成的this指向改变函数需要手动调用



### 如何实现一个call方法？说思路

* 





### 数组的reduce方法有用过吗？具体的用途？

* `reduce` 是 JavaScript 数组的一个高阶函数，用于将数组中的元素通过指定的回调函数累积为单个值

* 主要用途包括：

  * **求和或累积**：将数组中的元素累加或累积为一个值。
  * **数组转换**：将数组转换为其他数据结构，如对象或新数组。
  * **扁平化数组**：将多维数组转换为一维数组。
  * **统计**：计算数组中的最大值、最小值等。

  ```js
  array.reduce(callback(accumulator, currentValue, currentIndex, array), initialValue)
  ```

* 语法

  * **callback**：执行每个元素的函数，包含以下参数：
    - **accumulator**：累积值，初始值为 `initialValue` 或数组的第一个元素。
    - **currentValue**：当前处理的元素。
    - **currentIndex**（可选）：当前元素的索引。
    - **array**（可选）：调用 `reduce` 的数组。
  * **initialValue**（可选）：作为第一次调用 `callback` 时的 `accumulator` 初始值。如果未提供，则使用数组的第一个元素。

- 如果空数组调用reduce会发生什么？
  - 当空数组调用reduce()方法时，如果没有提供初始值参数，则会抛出一个TypeError错误。
  - 如果提供一个初始值参数作为reduce()的第二个参数, 那么会直接将这个初始值作为结果返回



### 使用过git吗？常用指令？

* 常用命令

  ```shell
  git clone
  git add .
  git commit -m "xxxx"
  git pull ->(git fetch + git merge)
  	# git fetch 从远程仓库获取最新的代码
    # git merge 获取到代码后默认并没有合并到本地仓库，我们需要通过merge来合并
  git push
  git checkout
  git merge
  git reset # 版本回退
  ```

- rebase、reset、revert区别？

  ```shell
  git rebase <branch>  # 衍合指定分支到当前分支 ->黄金原则: 不要在主分支中使用rebase
  git reset # 版本回退
  git revert <commit> # 插销指定提交
  ```

  

### 需要在本地实现一个聊天室，多个tab页相互通信，不能用websocket，你会怎么做？

* LocalStorage 和 SessionStorage

  * 在一个标签页中，将消息存储到 `LocalStorage` 或 `SessionStorage`。

  * 其他标签页通过监听 `storage` 事件来接收消息。

    ```js
    // 发送消息
    function sendMessage(message) {
      localStorage.setItem('chatMessage', JSON.stringify(message));
    }
    // 接收消息
    window.addEventListener('storage', (event) => {
      if (event.key === 'chatMessage') {
        const message = JSON.parse(event.newValue);
        console.log('Received message:', message);
      }
    })
    // 示例：发送消息
    sendMessage({ user: 'Alice', text: 'Hello, world!' });
    ```

* IndexedDB --- 虽然它主要用于存储数据，但也可以通过轮询或监听变化来实现跨标签页通信

  * 在一个标签页中将消息存储到 `IndexedDB`。

  * 其他标签页通过轮询或监听 `IndexedDB` 的变化来接收消息。

* BroadcastChannel API

  * `BroadcastChannel` 是一个现代浏览器提供的 API，允许同一域名下的不同标签页通过一个共享的频道进行通信。

  * 创建一个 `BroadcastChannel` 实例。

  * 使用 `postMessage` 方法发送消息。

  * 使用 `onmessage` 事件监听器接收消息。

    ```js
    // 创建频道
    const channel = new BroadcastChannel('chatChannel');
    
    // 发送消息
    function sendMessage(message) {
      channel.postMessage(message);
    }
    
    // 接收消息
    channel.onmessage = (event) => {
      console.log('Received message:', event.data);
    };
    
    // 示例：发送消息
    sendMessage({ user: 'Bob', text: 'Hi there!' });
    ```



### 说说的vue的响应式原理

* Vue2使用**Object.defineProperty**来实现数据的响应式。

  * 数据劫持
    * Vue 通过 `Object.defineProperty` 来劫持各个属性的 setter，getter
    * 当访问属性时，会触发 `getter`，Vue 会收集依赖（即哪些组件或视图依赖于这个属性）。
    * 当修改属性时，会触发 `setter`，Vue 会通知所有依赖进行更新。
  * 依赖收集
    * Vue 使用一个全局的 `Dep` 类来管理依赖
    * 每个属性都有一个对应的 `Dep` 实例，用于存储所有依赖于该属性的 `Watcher`
    * 当属性被访问时，当前的 `Watcher` 会被添加到 `Dep` 中
  * 派发更新
    * 当属性被修改时，`setter` 会通知 `Dep`，`Dep` 会遍历所有 `Watcher` 并调用它们的 `update` 方法。
    * `Watcher` 负责更新视图或执行其他逻辑。

  ```js
  function defineReactive(obj, key, val) {
    const dep = new Dep(); // 每个属性对应一个 Dep 实例
  
    Object.defineProperty(obj, key, {
      get() {
        if (Dep.target) { // 如果当前有 Watcher
          dep.addSub(Dep.target); // 收集依赖
        }
        return val;
      },
      set(newVal) {
        if (newVal === val) return;
        val = newVal;
        dep.notify(); // 通知所有 Watcher 更新
      },
    });
  }
  
  class Dep {
    constructor() {
      this.subs = []; // 存储 Watcher
    }
    addSub(sub) {
      this.subs.push(sub);
    }
    notify() {
      this.subs.forEach(sub => sub.update());
    }
  }
  
  class Watcher {
    update() {
      console.log('视图更新');
    }
  }
  ```

  

* defineProperty必须循环遍历 data 中的属性 设置getter、setter 不管我们用不用 初识化的时候都要循环遍历 这样才能做数据响应式 这是一种浪费

* 对于数组而言 是通过覆盖数组的对象原型 而重新实现的方法

* 新增或删除属性需要使用Vue.set/Vue.delete这个的特殊api才能生效

#### Vue3是怎么实现的？

* Vue 3 使用 **Proxy** 替代 **Object.defineProperty**，提供了更强大的响应式能力。
  * 数据劫持
    * Vue 3 使用 `Proxy` 代理整个对象，而不是像 Vue 2 那样逐个劫持属性。
    * `Proxy` 可以拦截对象的多种操作（如读取、赋值、删除等），从而实现更全面的响应式。
  * 依赖收集与派发更新
    * Vue 3 使用 `Reflect` 来操作对象，并通过 `Proxy` 的 `get` 和 `set` 拦截器来收集依赖和派发更新。
    * 依赖管理仍然通过 `Dep` 和 `ReactiveEffect`（类似于 Vue 2 的 `Watcher`）来实现
  * 惰性响应式
    * Vue 3 的响应式是惰性的，只有在访问属性时才会收集依赖，这提高了性能。

* `Proxy` 可以监听对象的所有操作，包括新增、删除属性以及数组的变化。
* **Vue 3**：基于 `Proxy`，功能更强大，性能更好，支持全面的响应式操作。



### proxy能够监听到对象中的对象的引用吗？

* **能监听到的，但需要递归地对嵌套对象进行代理。**

* Proxy 本身只能代理当前对象的第一层属性。如果对象的属性值仍然是对象，则需要递归地对这些嵌套对象也进行代理。

  * 这种特性通常称为“深度监听”或“懒监听”。

* **递归代理**：在 Proxy 的 `get` 拦截器中，如果发现属性值是对象，则递归地将其转换为响应式对象。

* **缓存代理对象**：为了避免重复代理同一个对象，可以使用一个 `WeakMap` 来缓存已经代理过的对象。

  ```js
  function reactive(obj) {
    // 缓存已经代理过的对象
    const proxyMap = new WeakMap();
  
    function createReactive(target) {
      if (typeof target !== 'object' || target === null) {
        return target; // 如果不是对象，直接返回
      }
  
      // 如果已经代理过，直接返回缓存的代理对象
      if (proxyMap.has(target)) {
        return proxyMap.get(target);
      }
  
      // 创建代理对象
      const proxy = new Proxy(target, {
        get(target, key, receiver) {
          const res = Reflect.get(target, key, receiver);
          track(target, key); // 收集依赖
          return createReactive(res); // 递归代理嵌套对象
        },
        set(target, key, value, receiver) {
          const oldValue = target[key];
          const res = Reflect.set(target, key, value, receiver);
          if (oldValue !== value) {
            trigger(target, key); // 派发更新
          }
          return res;
        },
        deleteProperty(target, key) {
          const hadKey = Object.prototype.hasOwnProperty.call(target, key);
          const res = Reflect.deleteProperty(target, key);
          if (hadKey) {
            trigger(target, key); // 派发更新
          }
          return res;
        },
      });
  
      // 缓存代理对象
      proxyMap.set(target, proxy);
      return proxy;
    }
  
    return createReactive(obj);
  }
  
  // 依赖收集与派发更新
  const targetMap = new WeakMap();
  
  function track(target, key) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, (depsMap = new Map()));
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, (dep = new Set()));
    }
    dep.add(activeEffect);
  }
  
  function trigger(target, key) {
    const depsMap = targetMap.get(target);
    if (!depsMap) return;
    const dep = depsMap.get(key);
    if (dep) {
      dep.forEach(effect => effect.run());
    }
  }
  
  let activeEffect;
  class ReactiveEffect {
    constructor(fn) {
      this.fn = fn;
    }
    run() {
      activeEffect = this;
      this.fn();
    }
  }
  
  function effect(fn) {
    const _effect = new ReactiveEffect(fn);
    _effect.run();
  }
  
  // 测试
  const obj = reactive({
    nested: {
      a: 1,
    },
  });
  
  effect(() => {
    console.log('nested.a:', obj.nested.a);
  });
  
  obj.nested.a = 2; // 输出: nested.a: 2
  ```

#### 如何让proxy去监听基本数据类型?

* proxy 无法直接监听基本数据类型的（如字符串、数字、布尔值等），因为它们是不可变的。Proxy只能在对象级别上进行操作，而不是基本数据类型。
* 用Proxy包装基本数据类型时，会得到一个TypeError错误，因为基本数据类型不具有属性和方法。
* 要监听基本数据类型，我们可以将基本数据包裹在对象中，并在该对象上实现监听



### Vuex用过吗？知道Vuex的原理吗？

* Vuex 的核心实现**依赖于 Vue 的响应式系统和发布-订阅模式**



* Store 类的实现
  - `Store` 类是 Vuex 的核心，负责管理 `state`、`getters`、`mutations` 和 `actions`。
  - 在 `Store` 的构造函数中，会初始化 `state` 并将其转换为响应式数据。
* 响应式state
  * Vuex 使用 Vue 实例的 `data` 选项将 `state` 转换为响应式数据。
  * 这样，当 `state` 发生变化时，依赖 `state` 的组件会自动更新。
* Mutations 和 Actions 的触发
  - `Mutations` 通过 `commit` 方法触发，直接修改 `state`。
  - `Actions` 通过 `dispatch` 方法触发，可以包含异步操作，最终通过 `commit` 提交 `mutation`。
* Getters 的实现
  - `Getters` 通过 `Object.defineProperty` 定义，其值是一个函数，依赖于 `state`。
  - `Getters` 的结果会被缓存，只有当依赖的 `state` 发生变化时才会重新计算。
* 模块化的实现
  - Vuex 的模块化通过递的方式实现。
  - 每个模块都有自己的 `state`、`getters`、`mutations` 和 `actions`，最终合并到根 `store` 中。



### 用过react吗？

### 用过ts吗？

### 用过node吗？



### 有做过工程化的事情吗？说一下你对工程化的了解，对webpack的了解

* 前端工程化 就是通过一些工具去提高效率、降低成本的一种手段。
* 我们从项目的创建到编码，再到预览/测试，再到提交，最后到部署，这每一个环节，我们实际上都可以通过工程化的方式大大提高我们的效率。
* 在创建项目环节
  * 使用脚手架工具自动地去帮我们完成基础结构的搭建
* 在编码环节中
  * 借助于工程化的工具自动化的去帮我们做一些事情
  * 比如做一些代码的格式化 / 以及代码风格的校验
* 在部署环节
  * 做一些自动化打包部署, 比如使用Jenkins





### webpack的rule，loader的执行流是怎么样的？



### 有自己写过loader、plugin吗？具体讲一下



### tree-shaking了解吗？讲一下

* 是一种用于移除 JavaScript 代码中未使用部分的优化技术
* Tree Shaking 的核心原理是基于 **ES Module**。ES Module 的特点是：
  - `import` 和 `export` 语句在代码编译时就能确定，而不是在运行时。
  - 通过静态分析，可以确定哪些模块、函数或变量被使用，哪些未被使用。

#### tree-shaking的操作是文件级别还是函数级别的

* Tree Shaking 的操作可以是 **文件级别** 或 **函数级别**，具体取决于工具的实现和代码的结构。
* 如果一个模块中没有任何内容被使用，整个模块会被移除。
* 如果一个模块中的某些函数或变量未被使用，这些具体的函数或变量会被移除。



### CI/CD了解吗？

* **CI/CD** 是现代软件开发中的一套核心实践，用于自动化软件交付流程
* **持续集成（Continuous Integration, CI）**
* **持续交付/持续部署（Continuous Delivery/Deployment, CD）** 
* 旨在提高开发效率、减少错误并加快软件发布速度。
* 一个典型的 CI/CD 流程包括以下步骤：
  * 代码提交 -- 将代码变更推送到版本控制系统（如 Git）
  * 持续集成（CI）
    * **触发构建**：代码提交后，CI 工具（如 Jenkins）自动触发构建流程。
    * **运行测试**：执行单元测试、集成测试等，确保代码变更没有引入错误。
    * **静态代码分析**：检查代码风格、安全性等问题。
  * 持续交付/持续部署（CD）
    * **部署到测试环境**：将构建产物部署到测试环境，进行更全面的测试
    * **手动/自动部署**：
      - **持续交付**：手动触发部署到生产环境。
      - **持续部署**：自动将代码变更部署到生产环境。
    * **监控和反馈**：监控生产环境的运行状态，收集反馈并快速修复问题。
* CI / CD核心组件
  * 版本控制系统 -- 如 Git、SVN
  * CI / CD工具 用于自动化构建、测试和部署
    * **Jenkins**：开源的 CI/CD 工具，功能强大且可扩展。
    * **GitHub Actions**：与 GitHub 深度集成，适合开源项目。
    * **GitLab CI/CD**：与 GitLab 深度集成，提供完整的 DevOps 解决方案。
  * 测试框架
    * **单元测试**：Jest、Mocha。
    * **集成测试**：Cypress、Selenium。
    * **性能测试**：JMeter、k6。
  * 构建工具
    * **Webpack**：用于前端项目的打包工具。
    * **Maven/Gradle**：用于 Java 项目的构建工具。
    * **Docker**：用于构建和发布容器镜像。
  * 部署工具
    * **Kubernetes**：用于容器化应用的部署和管理。
    * **Ansible**：用于自动化配置管理和部署。
    * **Terraform**：用于基础设施即代码（IaC）。
* 总结
  * **CI/CD** 是一套自动化软件交付流程，包括持续集成、持续交付和持续部署。
    * **搭建 CI/CD 管道需要一定的技术储备和时间投入。**
  * **核心目标**：提高开发效率、减少错误、加快发布速度、降低发布风险。
  * **关键实践**：自动化构建、测试和部署。
  * **工具链**：版本控制、CI/CD 工具、测试框架、构建工具、部署工具。
  * **优势**：提高效率、减少错误、快速反馈、降低风险。



### 设计模式了解吗？讲一下了解的、用过的





### 手写题

实现promise.all

翻转二叉树，二叉树的左右节点翻转






























