## 1. 什么是 HTTP 协议? HTTP 和 HTTPS 协议的区别?

* HTTP
  * `HTTP` (HyperText Transfer Protocol)，即**超文本运输协议**，是实现网络通信的一种规范
  * 在实际应用中，`HTTP`常被用于在**Web浏览器和网站服务器之间传递信息**，以**明文**方式发送内容，不提供任何方式的数据加密

* HTTPS
  * `HTTP`传递信息是以明文的形式发送内容，这并不安全。而`HTTPS`出现正是为了解决`HTTP`不安全的特性
  * 为什么HTTPS更安全?
    * HTTPS之所以比HTTP安全，是因为它利用 SSL/TLS协议传输 
    * HTTPS = HTTP + SSL/TLS，通过 `SSL`证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密
    * 在网络请求中，需要有很多服务器、路由器的转发。其中的节点都可能篡改信息，而如果使用HTTPS，密钥在终点站才会有。它包含证书、卸载、流量转发、负载均衡、页面适配、浏览器适配、 refer传递等技术，确保数据在传输过程中的安全性和完整性。

* 区别
  * HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理，相对更安全
  * HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443
  * HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP
  * HTTPS需要SSL，SSL 证书需要钱，功能越强大的证书费用越高



## 2. UDP 和 TCP? 区别? 应用场景

TCP (传输控制协议)和UDP (用户数据协议)是两种常见的传输层协议

* 链接性
  * TCP是面向连接的协议，在传输数据之前需要建立连接（三次握手），数据传输完成后需要关闭连接（四次挥手）
  * UDP是无连接的协议，不需要建立或关闭连接，发送方可以直接发送数据报，接收方也可以随时接收数据报。
* 可靠性
  * TCP提供可靠的传输服务
  * UDP则提供不可靠的传输服务，不检查数据包的顺序、错误或重传。如果数据包在传输过程中丢失或损坏，UDP不会采取任何补救措施。
* 传输效率
  * 由于TCP需要建立连接、确认数据、处理重传等步骤，其传输效率相对较低，但在需要可靠传输的场景下表现更好。
  * UDP不需要这些额外的步骤，因此传输效率更高，但这也意味着在传输过程中可能会丢失数据。
* 数据传输顺序
  * TCP保证数据包按顺序到达。它通过序列号和确认机制确保接收方按正确顺序接收到数据包。
  * UDP不保证数据包按顺序到达。每个数据包独立传输，接收方收到的数据包顺序可能与发送顺序不同。

* 流量控制和拥塞控制
  * TCP具有流量控制和拥塞控制机制，可以根据网络状况动态调整发送速率，以防止网络拥塞和丢包。
  * UDP没有这些机制，只负责将数据报从源端发送到目的端，不关心网络状况和数据传输质量。
* 应用场景
  * **TCP**通常用于需要可靠传输的场景，如文件传输、电子邮件、远程登录等
  * **UDP**常用于对实时性要求较高、但对数据可靠性要求不高的场景，如视频流、音频流、DNS查询、VoIP（网络电话）等



## 3. OSI七模型

计算机网络的机构体系分为三种

- OSI 体系结构(7层)
- TCP / IP 体系结构(4层)
- 五层体系结构 


<table>
	<tr>
		<td>OSI 体系结构</td>
		<td>TCP / IP 体系结构</td>
        <td>五层体系结构</td>
	</tr>
	<tr>
		<td>7 应用层</td>
		<td rowspan="3">4 应用层(HTTP)</td>
        <td rowspan="3">5 应用层</td>
	</tr>
	<tr>
		<td>6 表示层</td>
	</tr>
    <tr>
		<td>5 会话层</td>
	</tr>
    <tr>
		<td>4 传输层</td>
        <td>3 运输层(TCP UDP)</td>
        <td>4 运输层</td>
	</tr>
    <tr>
		<td>3 网络层</td>
        <td>2 网际层(IP)</td>
        <td>3 网络层</td>
	</tr>
    <tr>
		<td>2 数据链路层</td>
        <td rowspan="3">1 网络接口层</td>
        <td>2 数据链路层</td>
	</tr>
    <tr>
		<td>1 物理层</td>
        <td>1 物理层</td>
	</tr>
</table>

* TCP / IP体系结构应用较为广泛 是互联网采用的协议



## 4. 说一说 TCP / IP 协议

TCP/IP，**传输控制协议**/**网际协议**，是指能够在多个不同网络间实现信息传输的协议簇

- TCP（传输控制协议）
  - 一种面向连接的、可靠的、基于字节流的传输层通信协议

- IP（网际协议）
  - 用于封包交换数据网络的协议

TCP/IP协议不仅仅指的是`TCP`和`IP`两个协议，而是指一个由`FTP`、`SMTP`、`TCP`、`UDP`、`IP`等协议构成的协议簇，只是因为在`TCP/IP`协议中`TCP`协议和`IP`协议最具代表性

OSI 采用的七层模型； TCP/IP 是四层或五层结构



## 5. DNS协议是什么? 说一说完整的DNS查询流程

DNS（Domain Names System），域名系统是进行域名和与之相对应的 IP 地址进行转换的服务器

简单来讲，`DNS`相当于一个翻译官，负责将域名翻译成`ip`地址

域名是一个具有层次的结构，从上到下一次为根域名、顶级域名、二级域名、三级域名...

例如`www.xxx.com`，`www`为三级域名、`xxx`为二级域名、`com`为顶级域名，系统为用户做了兼容，域名末尾的根域名`.`一般不需要输入

* 域名缓存
  * 在域名服务器解析的时候，使用缓存保存域名和`IP`地址的映射
  * 计算机中`DNS`的记录也分成了两种缓存方式：
    * 浏览器缓存：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗
    * 操作系统缓存：操作系统的缓存其实是用户自己配置的 `hosts` 文件
* 查询过程
  * 首先搜索浏览器的 DNS 缓存
  * 若没有命中，则继续搜索操作系统的 DNS 缓存
  * 若仍然没有命中，则操作系统将域名发送至本地域名服务器
  * 若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行查询
  * 本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来
  * 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起
  * 至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起



## 6. 什么是CDN

CDN (全称 Content Delivery Network)，即内容分发网络

`CDN` 的关键技术主要有内容存储和分发技术

**简单来讲，CDN就是根据用户位置分配最近的资源**

于是，用户在上网的时候不用直接访问源站，而是访问离他“最近的”一个 CDN 节点，术语叫**边缘节点**，其实就是缓存了源站内容的代理服务器。

原理分析

* 在没有应用`CDN`时，我们使用域名访问某一个站点时的路径为

  ```js
  用户提交域名→浏览器对域名进行解释→DNS 解析得到目的主机的IP地址→根据IP地址访问发出请求→得到请求数据并回复
  ```

* 应用`CDN`后，`DNS` 返回的不再是 `IP` 地址，而是一个`CNAME`(Canonical Name ) 别名记录，指向`CDN`的全局**负载均衡**

* `CNAME`实际上在域名解析的过程中承担了中间人（或者说代理）的角色，这是`CDN`实现的关键

负载均衡系统

* 由于没有返回`IP`地址，于是本地`DNS`会向负载均衡系统再发送请求 ，则进入到`CDN`的全局负载均衡系统进行智能调度：
  * 看用户的 IP 地址，查表得知地理位置，找相对最近的边缘节点
  * 看用户所在的运营商网络，找相同网络的边缘节点
  * 检查边缘节点的负载情况，找负载较轻的节点
  * 其他，比如节点的“健康状况”、服务能力、带宽、响应时间等
* 结合上面的因素，得到最合适的边缘节点，然后把这个节点返回给用户，用户就能够就近访问`CDN`的**缓存代理**

缓存代理

* 缓存系统是 `CDN`的另一个关键组成部分，缓存系统会有选择地缓存那些最常用的那些资源
* 其中有两个衡量`CDN`服务质量的指标：
  - 命中率：用户访问的资源恰好在缓存系统里，可以直接返回给用户，命中次数与所有访问次数之比
  - 回源率：缓存里没有，必须用代理的方式回源站取，回源次数与所有访问次数之比

总结

* `CDN` 目的是为了改善互联网的服务质量，通俗一点说其实就是提高访问速度
* `CDN` 构建了全国、全球级别的专网，让用户就近访问专网里的边缘节点，降低了传输延迟，实现了网站加速



## 7. 说一说 HTTP1.0 / 1.1 / 2.0 的区别?

HTTP1.0：

- 浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接

HTTP1.1：

- 引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用
- 在同一个TCP连接里面，客户端可以同时发送多个请求
- 虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着
- 新增了一些请求方法
- 新增了一些请求头和响应头

HTTP2.0：

- 采用二进制格式而非文本格式
- 完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行
- 使用报头压缩，降低开销
- 服务器推送



## 8. HTTP 常用的状态码

状态码第一位数字决定了不同的响应状态

```js
1 表示消息
2 表示成功
3 表示重定向
4 表示请求错误
5 表示服务器错误
```

* 1xx: 代表请求已被接受，需要继续处理
* 2xx: 代表请求已成功被服务器接收、理解、并接受
  * 200（成功）：请求已成功
  * 201（已创建）：请求成功并且服务器创建了新的资源
  * 202（已创建）：服务器已经接收请求，但尚未处理
* 3xx: 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向
  * 301（永久移动）：请求的网页已永久移动到新位置。
  * 302（临时移动）：临时性重定向
  * 304（未修改）：果该资源自上次请求以来没有被修改，服务器会返回 304
* 4xx: 代表了客户端看起来可能发生了错误，妨碍了服务器的处理
  * 400（错误请求）： 服务器不理解请求的语法
  * 401（未授权）： 请求要求身份验证。
  * 403（禁止）： 服务器拒绝请求(没有权限)
  * 404（未找到）： 服务器找不到请求的网页
* 5xx: 服务器问题
  * 500（服务器内部错误）
  * 502（错误网关）
  * 503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）
  * 504（网关超时）
  * 505（HTTP 版本不受支持）



## 9. 说一说 GET 和 POST 的区别

`GET`和`POST`，两者是`HTTP`协议中发送请求的方法

* GET
  * `GET`方法请求一个指定资源的表示形式，使用GET的请求应该只被用于获取数据

* POST
  * `POST`方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或**副作用**

本质上都是`TCP`链接，并无差别

但是由于`HTTP`的规定和浏览器/服务器的限制，导致他们在应用过程中会体现出一些区别

```js
从w3schools得到的标准答案的区别如下：

GET在浏览器回退时是无害的，而POST会再次提交请求。
GET产生的URL地址可以被Bookmark，而POST不可以。
GET请求会被浏览器主动cache，而POST不会，除非手动设置。
GET请求只能进行url编码，而POST支持多种编码方式。
GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
GET请求在URL中传送的参数是有长度限制的，而POST没有。
对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
GET参数通过URL传递，POST放在Request body中
```

* 参数位置

貌似从上面看到`GET`与`POST`请求区别非常大，但两者实质并没有区别

无论 `GET`还是 `POST`，用的都是同一个传输层协议，所以在传输上没有区别

当不携带参数的时候，两者最大的区别为第一行方法名不同

```js
POST /uri HTTP/1.1 \r\n
GET /uri HTTP/1.1 \r\n
```

当携带参数的时候，我们都知道`GET`请求是放在`url`中，`POST`则放在`body`中

* 参数长度

`HTTP`协议没有`Body`和 `URL` 的长度限制，对 `URL`限制的大多是浏览器和服务器的原因

* 安全

`POST`比`GET` 安全，因为数据在地址栏上不可见

然而，从传输的角度来说，他们都是不安全的，因为`HTTP` 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文，只有使用`HTTPS`才能加密安全

* 数据包

对于`GET`方式的请求，浏览器会把`http header`和`data`一并发送出去，服务器响应200（返回数据）

对于`POST`，浏览器先发送`header`，服务器响应100 `continue`，浏览器再发送`data`，服务器响应200

并不是所有浏览器都会在`POST`中发送两次包，`Firefox`就只发送一次














































