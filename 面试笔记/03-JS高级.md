## 1. this绑定

### 1.1 this绑定规则有几种?

* 默认绑定: 独立函数调用 严格模式下,独立调用函数中的this指向是undefined
* 隐式绑定: 通过某个对象进行调用(也就是它的调用位置中，是通过某个对象发起的函数调用)
* 显示绑定: 明确的绑定this对象
  * apply（数组） / call（多参数）
  * bind
* new绑定: 当用new操作符时
  * 在内存中创建一个新的空对象
  * 构造函数的显示原型赋值给这个对象的隐式原型
  * this会指向创建出来的新对象**（this的绑定在这个步骤完成）**
  * 执行函数体中的代码
  * 默认返回这个对象,(如果没有返回非空对象时)



### 1.2 内置函数的调用绑定

内置函数  或者第三方库  我们不清楚函数里面的调用方式

* 定时器 -- window

  ```js
  setTimeout(function () {
  	console.log("定时器的this指向", this);
  }, 1000);
  ```

* 点击按钮的监听  -- 指向点击的这个按钮元素

  ```js
  btnEl.onclick = function () {
  	console.log("btn点击事件的this指向", this);
  };
  btnEl.addEventListener("click", function () {
  	console.log("btn点击事件的this指向", this);
  });
  ```

* forEach -- 没有传第二个参数,指向window  若传入第二个参数,this则指向第二个参数

  



### 1.3 this绑定规则的优先级

* 显式绑定优先级高于隐式绑定
* bind高于默认绑定
* new绑定优先级高于隐式绑定
* new/显式优先级
  * new不可以和apply/call一起使用
  * new优先级高于bind
* bind 和 apply/call的优先级
  * bind的优先级 高于 apply/call



### 1.4 this绑定其它情况

* 显式绑定null/undefined,那么使用的规则是默认绑定

  ```js
  foo.call(null); //window
  foo.call(undefined); //window
  ```

* 间接函数引用 -- `(obj2.foo = obj1.foo)();  //window`

* 箭头函数

  * 箭头函数中没有this
  * 箭头函数并不绑定this对象，那么this引用就会从上层作用于中找到对应的this



### 1.5 this面试题

```js
var name = "window";

var person = {
  name: "person",
  sayName: function () {
    console.log(this.name);
  },
};

function sayName() {
  var sss = person.sayName;

  sss(); //默认绑定: window

  person.sayName(); //隐式绑定: person

  //(person.sayName)(); // 隐式绑定 person  这里 .的优先级要高于()的优先级 --- 有没有这个()都一样的

  (b = person.sayName)(); // window 间接函数引用
}

sayName();
```

```js
var name = "window";

var person1 = {
  name: "person1",
  foo1: function () {
    console.log(this.name);
  },
  foo2: () => console.log(this.name),
  foo3: function () {
    return function () {
      console.log(this.name);
    };
  },
  foo4: function () {
    return () => {
      console.log(this.name);
    };
  },
};

var person2 = { name: "person2" };

// 开始题目:
person1.foo1(); //隐式绑定 person1
person1.foo1.call(person2); //显示绑定 person2

person1.foo2(); //window
person1.foo2.call(person2); //window

person1.foo3()(); //默认绑定(独立函数调用)window
person1.foo3.call(person2)(); //默认绑定(独立函数调用)window
person1.foo3().call(person2); //person2

person1.foo4()(); //person1
person1.foo4.call(person2)(); //person2
person1.foo4().call(person2); //person1
```

```js
var name = "window";
function Person(name) {
  this.name = name;
  this.foo1 = function () {
    console.log(this.name);
  };
  this.foo2 = () => console.log(this.name);
  this.foo3 = function () {
    return function () {
      console.log(this.name);
    };
  };
  this.foo4 = function () {
    return () => {
      console.log(this.name);
    };
  };
}

// person1/person都是对象(实例instance)
var person1 = new Person("person1");
var person2 = new Person("person2");

// 面试题目:
person1.foo1(); // person1
person1.foo1.call(person2); //person2

person1.foo2(); // person1
person1.foo2.call(person2); //person1

person1.foo3()(); // 独立函数调用window
person1.foo3.call(person2)(); // 独立函数调用 window
person1.foo3().call(person2); // 显式调用 person2

person1.foo4()(); // person1
person1.foo4.call(person2)(); //person2
person1.foo4().call(person2); // person1
```

```js
var name = "window";
function Person(name) {
  this.name = name;
  this.obj = {
    name: "obj",
    foo1: function () {
      return function () {
        console.log(this.name);
      };
    },
    foo2: function () {
      return () => {
        console.log(this.name);
      };
    },
  };
}

var person1 = new Person("person1");
var person2 = new Person("person2");

person1.obj.foo1()(); //独立函数调用 window
person1.obj.foo1.call(person2)(); //独立函数调用 window
person1.obj.foo1().call(person2); //显式绑定 person2

person1.obj.foo2()(); //obj
person1.obj.foo2.call(person2)(); //person2
person1.obj.foo2().call(person2); //obj
```



## 2. 作用域

### 2.1 什么是变量提升、函数提升？

* 在js的早期版本中（var关键字），js代码在执行前会进行预编译，预编译期间会将变量的声明与函数的声明提升至对应作用域的最顶端
* 函数内声明的变量只会提升至该函数作用域最顶层
* 函数提升只会提升函数声明式写法，函数表达式的写法不存在函数提升
* 函数提升的优先级大于变量提升的优先级，即函数提升在变量提升之上



### 2.2 说说你对 GO / AO / VO 的理解?

- **GO(Global Object 全局对象)**
  - js引擎会在执行代码之前在推内存中创建GO
  - 该对象所有作用域都可以访问
  - ⽤于存放⼀些定义好的变量⽅法，包含Math,String,Date等等
  - 同时有⼀个window属性指向⾃⼰
  - 转成AST的过程中也会将⼀些变量 函数 存放在GO中 只是变量的初始值为 undefined
- **VO(Variable Object 可变对象)**
  - 每个执行上下文都会关联一个VO
  - 全局执行上下文的VO就是GO
  - 函数执行上下文的VO就是AO
- **AO(Activation Object 活跃对象)**
  - AO是函数执行上下文所关联的VO
  - 存放arguments(有值的) 定义的变量



### 2.3 说说你对作用域和作用域链的理解？

* 作用域 --- 就是变量和函数能被访问的区域或集合
  * 在ES5中，一个全局作用域，函数也会产生作用域
  * 在ES6中，代码块、let、const等都会有属于自己的作用域
* 作用域链
  * 当在`Javascript`中使用一个变量的时候，首先`Javascript`引擎会尝试在当前作用域下去寻找该变量，如果找不到,就会去上层作用域找,直到找到全局作用域, 这样的一条链就是作用域链
  * 当进入到⼀个执行上下文时，执行上下文会关联⼀个作用域链
  * 通常作用域链在解析时就被确定，作用域链与函数的定义位置有关，与它的调用位置无关



### 2.4 你是如何理解闭包的,闭包到底是什么?

* 一个普通的函数function，如果它可以访问外层作用域的自由变量，那么这个函数和周围环境就是一个**闭包**
  * 自由变量: 就是函数外面可以自由访问的变量
* 从广义的角度来说：JavaScript中的函数都是闭包
* 从狭义的角度来说：JavaScript中一个函数，如果访问了外层作用域的变量，那么它是一个闭包
* 闭包的应用场景
  * 防抖 、节流 、立即执行函数 、组合函数等等
* 为什么要有闭包呢？
  * 闭包的存在让我们可以非常自然的访问外层作用域中的变量，不需要通过参数传递进来
  * 如果没有闭包，就会造成很多函数的参数是非常多和杂的，函数本身变得难以维护
  * 如果没有闭包，代码会非常混乱，代码的可读性，可扩展性，可维护性都会变差
  * 在开发中确实带来了很大的便利性，但是在不了解它原理的情况下也非常容易造成内存泄漏
    * 比如我们通过一个内层函数的内部引用了外层作用域的变量或函数，而之后不再使用该内层函数时，我们需要将其置为null
    * 如果没有这样操作，很容易造成内存泄漏，因为**这个外层作用域的变量或函数**长期被引用着而无法得到释放



## 3. 数组

### 3.1 常用的数组操作方法有哪些

* Array.shift() -- 删除并返回第一个元素

* Array.pop() -- 删除并返回最后一个元素

* Array.push() -- 在数组尾部添加元素 注意: 是直接修改该数组,而不是创建一个新数组

* Array.unshift() -- 在数组头部添加元素 注意: 也是直接修改该数组,而不是创建一个新数组

* Array.join() -- 将数组中的字符 连接成一个字符串

  ```js
  var arr = ["雨", "花", "印"]
  console.log(arr.join("-")) // 雨-花-印
  ```

* Array.reverse() -- 反转数组

* Array.slice() -- slice切,片 提取数组中的元素 [start, end) 不会修改原数组

  ```js
  var arr = ["雨", "花", "印", "aaa", "bbb"]
  console.log(arr.slice(1, 3)) // ["花", "印"]
  ```

* Array.concat() -- 将多个数组连接在一起

* ...



### 3.2 数组如何进行降维(扁平化)

* Array.some() -- 测试数组中是不是至少有 1 个元素通过了被提供的函数测试 返回一个Boolean类型

* 利⽤Array.some⽅法判断数组中是否还存在数组，es6展开运算符连接数组(严谨)

  ```js
  var arr = [1, 2, [3, 4]];
  if (arr.some((item) => Array.isArray(item))) {
  	arr = [].concat(...arr);
  }
  ```

* 利用数组的concat⽅法和扩展运算符

  ```js
  var arr = [1, 2, [3, 4]];
  var newArr = []
  newArr = [].concat(...arr)
  ```

* 普通递归实现

  ```js
  // 通过for循环的方式，逐层逐个元素地去展平，如果当前元素是一个数组，那么就对它进行递归处理，再将递归处理的结果拼接到结果数组上
  var arr = [1, 2, [3, 4, 5, [6, 6, 6]]];
  function newArr() {
    let result = []
      for(let i = 0; i < arr.length; i++){
          // 当前元素是一个数组，对其进行递归展平
          if(Array.isArray(arr[i])){
              // 递归展平结果拼接到结果数组
              result = result.concat(newArr(arr[i]))
          } else {
              // 否则直接加入结果数组
              result.push(arr[i])
          }
      }
      return result
  }
  ```
  
* es6中的flat` [flæt] `函数也可以实现数组的扁平化 -- 会按照一个可指定的深度递归遍历数组

  ```js
  var arr = [1, 2, [3, 4,[5, 6, 7]]];
  var newArr = arr.flat(2)
  ```

  

### 3.3 数组去重, 能有几种实现方案?

* Array.from() -- 对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例
  * **将类数组对象转换成数组**
  * 克隆一个数组 -- 实现数组的浅拷贝

* 利⽤ES6 Set去重（ES6中最常⽤） -- 缺点: 无法去掉 `{}` 空对象             

  ```js
  var arr = [1, 2, 3, 3, 4, 4, 5, 6, 6, 7, 7, {}, {}];
  function newArr(arr) {
      // return new Set(arr); 不可以
  	return Array.from(new Set(arr)); //new Set返回的是一个类数组对象,所以要用Array.from包裹
  }
  console.log(newArr(arr)); // Set[1, 2, 3, 4, 5, 6, 7, {} ,{}]
  ```

* 利⽤for嵌套for，然后splice去重（ES5中最常⽤）-- 缺点: `NaN`和`{}`没有去重

  ```js
  var arr = [1, 2, 3, 3, 4, 4, 5, NaN, NaN, null, null, {}, {}];
  // 两层循环 第一层将元素循环出来 第二层从下一个元素开始循环,与第一层的比较
  // 若arr[i] == arr[j] 通过splice删除掉
  function newArr(arr) {
      for (var i = 0; i < arr.length; i++) {
        for (var j = i + 1; j < arr.length; j++) {
          if (arr[i] == arr[j]) {
            arr.splice(j, 1);
            j--;
          }
        }
      }
      return arr;
  }
  console.log(newArr(arr)) // [1, 2, 3, 4, 5, NaN, NaN, null, {…}, {…}]
  ```

* 利⽤includes -- 缺点: 无法去掉 `{}` 空对象

  ```js
  var arr = [1, 2, 3, 3, 4, 4, 5, NaN, NaN, null, null, {}, {}];
  function newArr(arr) {
      if (!Array.isArray(arr)) {
        console.log("type error!");
        return;
      }
      var array = [];
      for (var i = 0; i < arr.length; i++) {
        if (!array.includes(arr[i])) {
          //includes 检测array数组是否有某个值
          array.push(arr[i]);
        }
      }
      return array;
  }
  console.log(newArr(arr)); // [1, 2, 3, 4, 5, NaN, null, {…}, {…}]
  ```

* 利用hasOwnProperty -- 都去重了 缺点:  看不懂

  * hasOwnProperty -- 返回一个布尔值，判断对象是否有某一个属于自己的属性

  ```js
  var obj = {
      name: "http",
      age: 18,
  };
  console.log(obj.hasOwnProperty("name")); //true
  console.log(obj.hasOwnProperty("height")); //false
  ```

  ```js
  var arr = [1, 2, 3, 3, 4, 4, 5, NaN, NaN, null, null, {}, {}];
  function newArr(arr) {
     var obj = {};
     return arr.filter((item, index, arr) => {
     		return obj.hasOwnProperty(typeof item + item) 
                 ? false 
          	   : (obj[typeof item + item] = true);
      });
  }
  console.log(newArr(arr)); // [1, 2, 3, 4, 5, NaN, null, {…}]
  ```

  

### 3.4 数组中forEach和map的区别

* 都支持3 个参数，参数分别是 item（当前每一项）， index（索引值），arr（原数组）
* 区别
  * // map速度比forEach快 
  * map有返回值,返回一个和原数组长度一致的新数组,由于这一点map可以进行链式操作
  * forEach没有返回值, 返回的是一个undefined
  * forEach在处理后会改变原数组的值,而map不会改变原数组,而是会生成一个新数组
* 使用场景
  * 当我们调用接口,返回的数据不满足我们的需求时,也就是说我们想改变数组的数据 就可以使用map 因为它会返回一个新数组 不影响原数据
    * 当我们不希望对数据做其他的事情, 比如就希望将展示出来 可以使用forEach



### 3.5 for和forEach的区别

* 中断循环

  * 在for循环中可以使用 `break` `return` `continue` 进行中断或跳出循环的操作
  * forEach不支持上述的中断行为(使用return并不会报错，但是不会生效)
    * 若是一定要在 forEach 中跳出循环 --- 使用 `try/catch`

* for循环可以控制循环的起点

  * forEach 的循环起点只能为0

* 性能

  * 在不同的电脑上面,量级的划分是有区别的
  * 数据量小(10万)的时候,forEach的性能会更好
  * 数据量大(1000万)的时候,for循环的性能会更好

  ```js
  // let arrs = new Array(10 0000); forEach更快
  let arrs = new Array(1000 0000); // for更快
  
  console.time("for"); // 启动计时器
  for (let i = 0; i < arrs.length; i++) {}
  console.timeEnd("for"); // 停止计时，输出时间
  
  console.time("forEach");
  arrs.forEach((arr) => {});
  console.timeEnd("forEach");
  ```

  





### 3.6 for in 和 for of的区别

* for in: 我们一般用来遍历对象的, 遍历的是对象的key值

  ```js
  const obj = { a: 1, b: 2, c: 3 };
  for (let key in obj) {
      console.log(key); // 输出: a, b, c
      console.log(obj[key]); // 输出: 1, 2, 3
  }
  ```

* for of: 只能遍历可迭代对象, 遍历的是值: String、Array、Map、Set、arguments对象、NodeList集合

* 区别
  * **for...in 可以遍历对象和数组，for...of 不能遍历对象**
  * for...in 循环不仅遍历对象的键名，还会遍历⼿动添加的其它键，甚⾄包括原型链上的键 
  * for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而for … of 只遍历当前对象不会遍历原型链
  
* 总结：

  * for...in 循环主要是为了遍历对象而生，不适用于遍历数组； 

  * for...of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象



## 4. 函数

### 4.1 说说apply / call / bind 的用法和区别

用法

* apply

  * 第一个参数: 绑定this
  * 第二个参数: 传入额外的实参, 以数组的形式

* call

  * 第一个参数: 绑定this
  * 参数列表: 后续的参数以多参数的形式传递, 会作为实参

* bind 让一个函数总是指向一个对象

  ```js
  var bar = foo.bind(obj);
  bar(); // this --> obj
  // 这里是独立函数的调用,为什么this不是指向window
  // 这里设计到规则优先级问题,这里的bind绑定的优先级 > 默认绑定
  ```

区别

* call、apply和bind都可以改变函数的this指向 第⼀个参数都是this要指向的对象
* 都可以后续为函数传参 apply是将参数并成⼀个数组，call和bind是将参数依次列出
* call、apply都是直接调⽤，bind生成的this指向改变函数需要手动调用



### 4.2 什么是纯函数? 如何编写纯函数?

* 纯函数：纯函数⼀般具有以下的特点
  * 确定的输⼊⼀定会有确定的输出（外部环境的任何变化不会影响函数内部的操作产⽣的结果） 
  * 纯函数的执⾏不会产⽣副作⽤。（函数内部的操作也不会对函数外部产⽣任何影响）
* 纯函数在react和redux中应⽤⽐较多
* 编写纯函数 -- ⼀般的数学⽅法可以写成纯函数,例如相加



### 4.3 什么是函数柯里化?柯里化有什么作用?

* 函数的柯里化
  * 将传入多个参数的函数转变成传入单个参数 并且返回一个接收剩余参数的函数
  * 每一层函数都只接收一个参数进行处理
* 柯里化的作用
  * 单⼀职责：每⼀个函数只⽤处理传⼊的单个参数，每个函数的职责单⼀⽽且确定 
  * 参数复⽤：可以拿到每⼀层函数执⾏的返回值作为⼀个新的函数，复⽤已经传⼊过的参数



### 4.4 什么是组合函数?组合函数有什么作用?

* 组合函数
  * 组合函数是将多个函数组合到⼀起，进⾏依次调⽤的函数使⽤模式
* 组合函数的作用
  * 减少重复代码的编写，提⾼代码的复⽤性，便于开发
  * 可以对任意个函数进⾏组合，返回新的具有多个被组合函数功能的新函数



### 4.5 说说你对严格模式的理解

* 严格模式是⼀种JavaScript的限制模式
* JavaScript在不断的发展过程中并没有带来任何兼容性问题,新特新的不断加入,但是旧特性没有改变
* 这样有利于兼容就代码,但是这样 js中的一些错误或者不完善的地方永远的保留了下来
* 所以在**es5中**JavaScript提出了严格模式,在严格模式下会以更加严格的方式对代码进行检测和执行
* 在开启了严格模式后，js引擎会以⼀种更严格的规范执⾏ JavaScript代码，⼀些不规范的写法和错误也会直接抛出
* **class会默认开启严格模式 / babel也会默认开启严格模式**

* 严格模式下的语法限制：
  * 不允许意外的创建全局变量  -- function foo() { message: "大大怪将军" } //message is not defined
  * 不允许函数参数有相同的名称
  * 不允许只有0开头的⼋进制语法 
  * 不允许使⽤with
  * 在严格模式下,默认函数调用的this不再指向window 而是 undefined



## 5. 浏览器和V8

### 5.1 浏览器内核是什么?有哪些常见的浏览器内核?

* 浏览器内核⼜称浏览器渲染引擎，是浏览器的最核心部分。负责解析网页语法并渲染网页
* 常见的浏览器内核有：
  * trident（三叉戟）---- IE浏览器、360安全浏览器、UC浏览器、搜狗⾼速浏览器、百度浏览器 
  * gecko（壁⻁） ---- Mozilla、Firefox 
  * pestro -> Blink ---- Opera 
  * Webkit ---- Safari、360极速浏览器、搜狗⾼速浏览器、移动端浏览器 
  * Webkit -> Blink ----Chrome、Edge



### 5.2 说说浏览器输入一个url到页面的显示过程

* 输入URL(输入域名)

  * 首先会检测输入的内容是否是一个合法的URL连接
  * 判断URL是否完整,若不完整,浏览器可能会进行猜测,自动补全前缀或后缀

* 域名会通过DNS,解析成对应的服务器ip

* 然后与服务器建立TCP连接

* 发送 HTTP / HTTPS 请求（建⽴ TLS 连接）

  * 向服务器 发起 TCP 连接请求

  * 当这个请求到达服务端后，通过 TCP 三次握⼿，建⽴ TCP 的连接

    * 客户端发送 SYN 包到服务器，并进⼊ SYN_SEND 状态，等待服务器确认
    * 服务器收到 SYN 包，必须确认客户的 SYN，同时⾃⼰也发送⼀个 SYN 包，这个包为 SYN+ACK，此时服务 器进⼊ SYN_RECV 状态
    * 客户端收到服务器的 SYN包，向服务器发送 确认包(ACK)，此包发送完毕，客户端和服务器进⼊ ESTABLISHED 状态，完成三次握⼿

    ```js
    syn: synchronization同步
    ACK: acknowledgment确认
    SYN_SEND: syn_send 同步发送
    SYN_RECV: syn_recv 同步接收
    客户端发送 SYN 包到服务器，表示客户端想和服务端进行数据的同步
    ```

* 与服务器建立连接后, 服务器返回静态资源给浏览器, 内容包括相关响 应头和 HTML 正⽂

* **渲染引擎(就是浏览器内核)在拿到一个页面后**

  * 解析html,生成DOM树
  * 解析过程中,如果遇到css的link元素,会下载对应的css文件, 生成对应的规则树(CSSOM css对象模型 css Object Model)
    * 下载css文件并不会影响DOM树的解析,下载玩css文件后,就会对css文件进行解析,生成CSSOM
    * 下载css文件和生成DOM树是同时进行
  * 根据DOM Tree 和CSSOM Tree来构建Render Tree(渲染树)
    * link元素不会阻塞DOM tree的构建过程,但是会阻塞Render tree的构建
    * Render tree和DOM tree并不是一一对应关系(对于display:none的元素,就不会出现在Render tree中)
  * 布局(Layout): 根据渲染树来布局,计算每个节点的几何信息
  * 绘制(Paint): 将各个节点绘制到屏幕上

* HTTP 请求结束，断开 TCP 连接(四次挥手)

为什么不是两次握手

如果是两次握手，发送端可以确定自己发送的信息能对方能收到，也能确定对方发的包自己能收到，但接收端只能确定对方发的包自己能收到 无法确定自己发的包对方能收到

并且两次握手的话, 客户端有可能因为网络阻塞等原因会发送多个请求报文，延时到达的请求又会与服务器建立连接，浪费掉许多服务器的资源



### 5.3 说说你对JS引擎的理解

* 首先 JavaScript 是⼀门解释型语言
* JS 引擎就是 JavaScript 语⾔的运行解释器
* 浏览器内核中有两种引擎，其中⼀种就是 JS 引擎
  * **排版引擎** 负责 HTML 和 CSS 解析和排版
  * **JS** **引擎** 负责解析和运行 JavaScript 语句
* 常见 JS 引擎有
  * Chrome -> V8 -> 谷歌/Node.js 开发
  * ⼩程序 -> JSCore -> 腾讯开发



### 5.4 说说V8引擎的内存管理

* 不管什么样的编程语言，在**代码的执行过程中都是需要给它分配内存**的,不同的是一些语言需要我们手动的管理内存， 有些会可以自动帮助我们管理内存
  * 手动管理内存: C / C++
  * 自动管理内存: JavaScript / GO / Java / PHP
* **JavaScript的内存管理是自动的**
* **原始数据类型 直接在栈内存中分配**
* **复杂数据类型 在堆内存中分配**



### 5.5 说说V8引擎的垃圾回收器

* 垃圾回收(是Garbage Collection，简称GC)

* 因为内存大小是有限的 所以我们定义的变量在内存不需要的时候 需要进行释放 用于腾出空间

  * 原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存
  * 通常情况下有两种实现方式：引用计数 标记清除

* 常见的算法

  * 引用计数
    * 当⼀个对象有引用指向它时 对应的引用计数+1
    * 当没有对象指向它时 则为0 此时进行回收
    * 在一些特殊的情况 - 比如相互引用的时候，各自的引用都是1，所以不会被收回，造成内存泄露
    
    ```js
    function fn () {
      const obj1 = {}
      const obj2 = {}
      obj1.a = obj2
      obj2.a = obj1
    }
    fn()
    ```
    
  * 标记清除
    * 核心思路: 可达性
    * 从从初始的根对象开始，找所有从根开始有引用到的对象，对于哪些没有引用到的对象，就认为是不可用的对象
    * 对于不可用的对象 则进行回收 有效的解决了循环引用的问题
    * 目前V8引擎采用的就是该算法

* 我们都知道，JavaScript数据类型分为基本数据类型和引用数据类型

  * 基本数据类型：拥有固定的大小，值保存在`栈内存`里，可以通过值直接访问
  * 引用数据类型：大小不固定(可以加属性)，`栈内存`中存着指针，指向`堆内存`中的对象空间，通过引用来访问
  * 由于栈内存所存的基础数据类型大小是固定的，所以栈内存的内存都是`操作系统自动分配和释放回收的`
  * 由于堆内存所存大小不固定，系统`无法自动释放回收`，所以需要`JS引擎来手动释放这些内存`

* 为什么要垃圾回收？

  * 在Chrome中，V8被限制了内存的使用`（64位约1.4G/1464MB ， 32位约0.7G/732MB）`，为什么要限制呢？
  * 表层原因：V8最初为浏览器而设计，不太可能遇到用大量内存的场景
  * 深层原因：V8的垃圾回收机制的限制（如果清理大量的内存垃圾是很耗时间，这样会引起JavaScript线程暂停执行的时间，那么性能和应用直线下降）

* V8引擎为了优化 在采用标记清除的过程中也引用了其他的算法

  * `标记整理`  `分代收集`  `增量收集`  `闲时收集`

  ```js
  * 分代收集
  在JavaScript中，对象存活周期分为两种情况
   - 存活周期很短：经过一次垃圾回收后，就被释放回收掉
   - 存活周期很长：经过多次垃圾回收后，他还存在，赖着不走
  那么问题来了，对于存活周期短的，回收掉就算了，但对于存活周期长的，多次回收都回收不掉，明知回收不掉，却还不断地去做回收无用功，那岂不是很消耗性能？
  对于这个问题，V8做了分代回收的优化方法
  通俗点说就是：V8将堆分为两个空间，一个叫新生代，一个叫老生代，新生代是存放存活周期短对象的地方，老生代是存放存活周期长对象的地方
  ```
  
  ```js
  * 标记整理
  和标记清除相似 不同的是回收时 会将保留下来的存储对象整合到连续的内存空间 避免内存碎⽚化
  * 增量收集
  如果存在许多对象 则GC试图⼀次性遍历所有的对象 可能会对性能造成⼀定的影响
  所以引擎试图将垃圾收集⼯作分成⼏部分 然后这⼏部分逐⼀处理 这样会造成微⼩的延迟⽽不是很⼤的延迟
  * 闲时收集
  GC只会在CPU空闲的时候运⾏ 减少可能对代码执⾏造成的影响
  ```



### 5.6 V8引擎执行代码的大致流程

* **JS代码 ---(解析器)---> AST树 ---(解释器)---> 字节码**

* 在JS代码 解析成 AST树的过程

  * AST 抽象语法树 是源代码语法结构的一种抽象表示
    * AST在现实的编程中也有很大的作用 比如说babel 就是通过AST进行工作的
    * ES6的代码解析成ES6的抽象语法树,再转化成ES5的抽象语法树,最终再转化成ES5的代码
  * AST是如何产生的呢?

  ```js
  let name = "Long";
  // 定义一个name属性 为一个字符串
  // 解析器第一步要做的 就是将这个语句拆分成最小的不可拆分的单元 - 这一过程叫做词法分析
  let    关键字
  name   标识符
  =      赋值符号
  "Long" 字符串
  ;      符号
  // 这些字符或字符串 又称为token 拆分结构构如下
  [
      {
          "type": "Keyword",
          "value": "let"
      },
      {
          "type": "Identifier",
          "value": "name"
      },
      {...},{...},{...}
  ]
  // 然后就是语法分析
  将上一步生成的token数据,根据语法规则转为AST树
                   
  // 1.通过词法分析将每一行代码分解成有意义的代码块 这些代码块被称为token
  // 2.语法分析:将上一步生成的token数据,根据语法规则转为AST树
  ```

* AST生成字节码(ByteCode) 交给CPU执⾏
  * 过程中同时会收集优化所需的信息 
  * 将可优化的信息 通过TurBoFan编译器 编译成更好使⽤的机器码交给CPU执⾏
  * 为什么是转化成字节码而不是机器码呢?
    * 因为机器码所占的空间远远超过了字节码,所以是用字节码可以减少系统内存的是用



### 5.7 说说线程和进程的区别以及关系

* 进程
  * 操作系统中最核心的概念就是进程，进程是对正在运行中的程序的一个抽象，是系统进行资源分配和调度的基本单位
  * 是 cpu 分配资源的最小单位
  * 计算机已经运行的程序，是操作系统管理程序的一种方式 (**官方说法**)
  * 启动一个应用程序，就会默认启动一个进程（也可能是多个进程）
* 线程
  * 是 cpu 调度的最小单位
  * 通常情况下它被包含在进程中
* **操作系统的工作方式**
  * 如何做到同时让多个进程同时⼯作? 
    * 因为 CPU 的运算速度非常快, 可以快速的在多个进程之间迅速的切换 
    * 当进程中的线程获取到世间片时, 就可以快速执行我们编写的代码 
    * 由于 CPU 执行速度过于变态, 对于用户来说是感受不到这种快速切换的



### 5.8 JavaScript为什么是单线程

* 这主要和js的用途有关，js是作为浏览器的脚本语⾔，主要是实现用户与浏览器的交互，以及操作dom

* 这决定了它只能是单线程，否则会带来很复杂的同步问题

* 比如js被设计了多线程，如果有一个线程要修改一个dom元素，另一个线程要删除这个dom元素， 此时浏览器就会一脸茫然，不知所措



### 5.9 浏览器是多线程的

* 在浏览器中，每打开⼀个tab⻚⾯，其实就是新开了⼀个进程，在这个进程中，还有ui渲染线程，js 引擎线程，http请求线程等
* 因此浏览器是⼀个多进程的
* 为了利⽤多核CPU的计算能⼒，HTML5提出Web Worker标准，允许 JavaScript脚本创建多个线程，但是⼦线程完全受主线程控制，且不得操作DOM。所以，这个新标 准并没有改变JavaScript单线程的本质。



### 5.10 什么是重排重绘? 如何减少重排重绘?

* 重排又叫回流
  * 第一次确定节点的大小和位置，称之为布局（layout）
  * 之后对节点的大小、位置修改重新计算称之为回流
  * 当⼀个元素位置发⽣变化时，其⽗元素及其后边的元素位置 都可能发⽣变化，代价极⾼
  * 什么情况下引起回流呢？
    * 比如DOM结构发生改变（添加新的节点或者移除节点）
    * 比如改变了布局（修改了width、height、padding、font-size等值）
    * 比如窗口resize（修改了窗口的尺寸等）
    * 比如调用getComputedStyle方法获取尺寸、位置信息
* 重绘
  * 第一次渲染内容称之为绘制（paint）
  * 之后重新渲染称之为重绘
  * 修改背景色、文字颜色、边框颜色、样式等会引起重绘
* **重排一定会引起重绘,所以回流是一件很消耗性能的事情**。 尽量避免回流
  * 减少DOM操作
  * 一次性修改样式
  * 使用position的absolute或者fixed(并不是不会引起回流，而是开销相对较小，不会对其他元素造成影响)



### 5.11 合成composite

- 绘制的过程，可以将布局后的元素绘制到多个合成图层中 --- 这是浏览器的一种优化手段
- 默认文档流中的内容都是最终放到一个合成图层中
- 一些特殊的属性，会创建一个新的合成层（ CompositingLayer ），并且新的图层可以利用GPU来加速绘制
  - 因为每个合成层都是单独渲染的
- 某些特殊的CSS属性, 会生成新的合成图层:
  - position: fexied
  - transform 3D
  - will-change
  - opacity在执行动画
  - animation/transition执行transform
- 分层确实可以提高性能，但是它以内存管理为代价，因此不应作为 web 性能优化策略的一部分过度使用



### 5.12 说一说浏览器的缓存机制

**什么事浏览器缓存?**

- 它通过将资源存储在本地，避免重复下载相同内容
- 是提高网页加载速度和减少网络流量的重要手段



**什么事浏览器的强缓存和协商缓存**

* 强缓存
  * 是指浏览器在缓存有效期内直接使用缓存，而不向服务器发送请求
* 协商缓存
  * 是指浏览器在缓存过期后，会向服务器发送请求，验证缓存数据是否过期



**缓存位置**

- **Memory Cache**：存储在内存中，读取速度快，但容量有限，通常用于存储较小的资源
- **Disk Cache**：存储在硬盘中，容量较大，适合存储较大的资源，如图片、视频等



**缓存分类**

- **强缓存**：浏览器直接从缓存中读取资源，不向服务器发送请求。通过 `Expires` 和 `Cache-Control ` 头控制。
- **协商缓存**：浏览器向服务器发送请求，验证资源是否更新。通过 `ETag` 和 `Last-Modified` 头控制。
- 浏览器再向服务器请求资源时,首先判断是否命中强缓存,再判断是否命中协商缓存



**强缓存**

- 浏览器在加载资源时，会先根据本地缓存资源的 header 中的信息判断是否命中强缓存，如果命中则直接使用缓存中的资源不会再向服务器发送请求。
- Expires
  - 该字段是 **http1.0** 时的规范，它的值为一个绝对时间的 GMT 格式的时间字符串，比如 Expires:Mon,18 Oct 2066 23:59:59 GMT。这个时间代表着这个资源的失效时间，在此时间之前，即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。
- Cache-Control
  - Cache-Control 是 **http1.1** 时出现的 header 信息，主要是利用该字段的 max-age 值来进行判断，它是一个相对时间，例如 Cache-Control:max-age=3600，代表着资源的有效期是 3600 秒。
  - 还有下面几个比较常用的设置值
    - `max-age=<seconds>`：资源的最大缓存时间。
    - `no-cache`：每次请求都需向服务器验证资源是否过期。
    - `no-store`：禁止缓存资源。
    - `public`：资源可被所有用户缓存。
    - `private`：资源仅可被单个用户缓存。



**协商缓存**

- 当强缓存没有命中的时候，浏览器会发送一个请求到服务器，服务器根据 header 中的部分信息来判断是否命中缓存。如果命中，则返回 304 ，告诉浏览器资源未更新，可使用本地的缓存。
- Last-Modified
  - 资源的最后修改时间，用于验证资源是否发生变化。客户端通过`If-Modified-Since`头将上次获取资源的时间发送给服务器，服务器通过比较时间来判断资源是否更新。
- ETag
  - 资源的唯一标识符，用于验证资源是否发生变化。服务器通过比较客户端发送的`If-None-Match`头与当前资源的`ETag`来判断资源是否更新。
- **Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。**



**缓存优化**

为了充分利用浏览器缓存，开发者可以采取以下优化措施：

- **合理设置缓存时间**：对于静态资源（如CSS、JS、图片等），可以设置较长的缓存时间，减少重复请求。
- **使用版本号或哈希值**：在资源URL中加入版本号或哈希值，确保资源更新后URL发生变化，强制浏览器获取新资源。
- **区分公共资源和私有资源**：通过`Cache-Control`的`public`和`private`指令，合理控制资源的缓存范围。



**缓存问题及解决方案**

- **缓存污染**：旧资源未及时更新，导致用户看到过期内容。解决方案是使用版本号或哈希值更新资源URL。
- **缓存穿透**：频繁请求不存在的资源，导致缓存失效。解决方案是设置合理的缓存策略，并使用CDN等缓存层。



## 6. 面向对象

### 6.1 什么是原型? 什么是原型链？

* 原型
  * 在JavaScript中每个对象都会有一个特殊的内置属性[[prototype]]，这个属性就是对象的原型，这个属性的值也是一个对象，是原对象的原型对象  --- [[prototype]]就是隐式原型
  * 在访问对象的属性时，会先在自身进行查找，若没有找到，就会去对象的原型上找
  * 对象获取原型的方式 --- `__proto__` 和 `Object.getPrototypeOf()`
  * 函数获取原型 --- 通过函数的`prototype`属性获取
* 原型链
  * 在对象中获取属性时,若在当前对象中没有该属性,就会在该对象的原型上查找
  * 而这个对象的原型也是一个对象,这个对象也会有原型,这样会一直的找下去,直到找到Object的原型上
  * 这样的链式结构就叫做原型链
  * Object的的原型对象的[[prototype]]属性为null(在最后这里没有找到就会返回undefined)



什么是显示原型和隐式原型?

- **显示原型 (prototype)**：是**函数**对象的属性，用于定义实例共享的属性和方法。
- **隐式原型 (__ proto __)**：是**对象**的属性，指向创建该对象的构造函数的 `prototype`，用于实现原型链。



### 6.2 如何通过原型链实现继承？

* 父类Person -- 子类Student
* 子类要继承父类 有一种比较简单的方法
  * 将父类的原型对象赋值给子类的原型 -- `Student.prototype = Person.prototype`
  * 但是这样有个缺点: 父类和子类共享同一个对象,修改其中一个另一个也会被修改
* 所以我们可以创建一个**"中间件"**  --  Student要继Person的方法 要满足的条件:
  * **必须创建出来的个对象**
  * **这个对象的隐式原型必须指向父类的显示原型**
  * **将这个对象赋值给子类的显示原型**

* 而通过原型链实现继承 就是围绕这个**"中间件"**来实现的

```js
// 方案一:
var obj = {};
// obj.__proto__ = Person.prototype; 因为__proto__是浏览器实现的,会有兼容问题
// 所以操作对象的隐式原型一般使用在 ES6 中的 Object.getPrototypeOf() 和 Object.setPrototypeOf()
Object.setPrototypeOf(obj, Person.prototype);
Student.prototype = obj;

// 方案二: 兼容性最好
function F() {}
F.prototype = Person.prototype;
var obj = new F();
Student.prototype = obj;

function F() {}
F.prototype = Person.prototype;
Student.prototype = new F();

// 方案三: Object.create: 创建一个新对象
// 创建一个新对象,将这个新对象的隐式原型指向Person.prototype
var obj = Object.create(Person.prototype);
Student.prototype = obj;
```

````js
//创建对象的过程
function createObject(obj) {
  function F() {}
  F.prototype = obj;
  return new F();
}
// 寄生式函数
function inherit(Subtype, Supertype) {
  Subtype.prototype = createObject(Supertype.prototype);
  Object.defineProperty(Subtype.prototype, "constructor", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: Subtype,
  });
}
function Person(name,age){
    this.name = name
    this.age = age
}
function Student(name,age,sno) {
    Person.call(this,name,age)
    this.sno = sno
}
inherit(Student,Person)
````





```js
对象没有显示原型 函数有隐式原型也有显示原型
obj.__proto__ --> 有值
obj.prototype --> undefined
Foo.__proto__ --> ƒ () { [native code] }
Foo.prototype --> {constructor: ƒ, [[prototype]]: Object} -- 这里的constructor是指向自己的

函数显示原型对象上有一个重要的属性:constructor 指向自己
```



6.3 继承各个方案以及优缺点?



## 7. ES6-13

### 7.1 说说var let和const的区别?

**作用域提升** **暂时性死区** **块级作用域** **重复声明** **修改声明的变量**

* 作用域提升
  * var声明的变量是会进行作用域提升的
  * 而let和const不会
* 暂时性死区
  * let和const是有暂时性死区的
* 块级作用域
  * let和const声明的变量时存在块级作用域的
  * 而var不存在
* 重复声明
  * var允许重复声明变量
  * let和const在同意作用域下 是不允许重复声明变量的
* 修改声明的变量
  * var和let 可以修改声明的变量
  * 而const声明的变量 不能被修改 但是如果是引用类型 可以通过引用找到对应的对象,修改对象的内容

**补充**

* const 保证的并不是变量的值不能改变，而是变量指向的那个内存地址不能改变
* 对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量
* 但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const 只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了



### 7.2 说说ES6~ES13新增了那些特性?

ES6

* let/const声明变量

* 函数的默认参数

  ```js
  // 如果参数不传进来，你就设置默认参数
  function fn (name, age) {
    var name = name || '发生肾么事了'
    var age = age || 18
    console.log(name, age)
  }
  fn() // 发生肾么事了 18
  
  // 但是这么写确实不优雅，可以使用ES6的默认参数
  function fn (name = '发生肾么事了', age = 18) {
    console.log(name, age)
  }
  fn() // 发生肾么事了 18
  fn('龙', 22) // 龙 22
  ```

* 展开语法 -- 其实是⼀种浅拷贝 Foo(...arr){}

  ```js
  // 曾经想要拼接多个数组，我们只能这么做
  const arr1 = [1, 2, 4]
  const arr2 = [4, 5, 7]
  const arr3 = [7, 8, 9]
  const arr = arr1.concat(arr2).concat(arr3) // [1, 2, 4, 4, 5, 7, 7, 8, 9]
  
  // 现在我们可以更优雅地进行拼接
  const arr = [...arr1, ...arr2, ...arr3] // [1, 2, 4, 4, 5, 7, 7, 8, 9]
  ```

* 函数的剩余参数

  ```js
  function fn (name, ...params) {
    console.log(name)
    console.log(params)
  }
  fn("发生肾么事了", 18, 1.88) // 发生肾么事了 [18, 1.88]
  ```

* 模板字符串

  ```js
  // 以前拼接字符串只能这么做
  const name = '发生肾么事了'
  const age = '18'
  console.log(name + '今年' + age + '岁啦') // 发生肾么事了今年18岁啦
  
  // 现在这样做更加优雅
  console.log(`${name}今年${age}岁啦`)
  ```

* 对象字面量增强

* Object.keys

  ```js
  // 用来获取对象的key的集合，进而获得对应key的value
  const obj = {
    name: '发生肾么事了',
    age: 22,
    gender: '男'
  }
  const keys = Object.keys(obj)
  console.log(keys) // [ 'name', 'age', 'gender' ]
  ```

* 解构赋值

  ```js
  // 以前想提取对象里的属性需要这么做
  const obj = {
    name: '发生肾么事了',
    age: 22,
  }
  const name = obj.name
  const age = obj.age
  console.log(name, age, gender) // 发生肾么事了 22
  
  // es6新增了解构赋值的语法
  const { name, age } = obj
  console.log(name, age, ) // 发生肾么事了 22
  // 解构重名
  const { name: myname } = obj
  console.log(myname) // 发生肾么事了
  ```

* 使用class定义类

  ```js
  // 以前我们使用构造函数生成对象,需要这样写
  function Person(name) {
    this.name = name
  }
  Person.prototype.sayName = function () {
    console.log(this.name)
  }
  const kobe = new Person('科比')
  kobe.sayName() // 科比
  
  // ES6的class可以这么做
  class Person {
    constructor(name) {
      this.name = name
    }
    sayName() {
      console.log(this.name)
    }
  }
  const kobe = new Person('科比')
  kobe.sayName() // 科比
  
  // 值得一提的是，class本质也是function，class是function的语法糖
  class Person {}
  console.log(typeof Person) // function
  ```

* 箭头函数

* forEach / map

* Promise

* 新增symbol数据类型

* Set WeakSet Map WeakMap

* 规范了二进制和八进制的写法

ES7

* Array.prototype.includes -- 判断一个数组是否包含指定的元素 返回布尔值

* 求幂运算符

  ```js
  const num = Math.pow(3, 2) // 9
  
  // ES7提供了求幂运算符：**
  const num = 3 ** 2 // 9
  ```

ES8

* Object values -- 获取对象的value值
* Object entries -- 可以用来获取对象的键值对集合
* async / await
* String Padding -- padStart/padEnd 分别对字符串首尾进行填充
* Object.getOwnPropertyDescriptors() -- 用于获取对象的所有自身属性的描述符

ES9

* 构建字面量对象时,可以使用展开运算符

ES10

* flat -- 对数组进行扁平化 传入一个指定的深度递归遍历数组
* flatMap -- 先进行map操作 再做flat操作
* trimStart / trimEnd -- 去除字符串前面或后面的空格

ES11

* BigInt
* 可选链 ?.
* 空值合并操作符 ?? 当前面的值为null或undefined时,显示??后面的值
* for..in标准化

ES12

- FinalizationRegistry对象可以让你在对象被垃圾回收时请求一个回调
- WeakRef 给对象赋值一个弱引用
- 逻辑赋值运算符 `||=` `??=` `&&=`
- String.replaceAll：字符串替换

ES13

- hasOwn: 判断一个对象中是否有某个自己的属性
- class中新成员: 公有属性 私有属性#



### 7.3 说说Set WeakSet Map WeakMap的特点?

在es6之前: 存储数据的结构主要有两种: 数组和对象

es6之后: 新增了另外两种数据结构 Set Map, 以及他们另外的两种新式WeakSet,WeakMap

他们是一种数据结构

* **Set :用来存取数据，类似于数组**
  - 类似于数组，但是和数组的区别是元素不能重复
  - Set中存放的元素是不会重复的,所以Set一个非常常用的功能就是给数组去重
  - 支持for of的遍历
* **WeakSet**
  - 与Set一样内部元素不能有重复的数据结构
  - 和Set的区别
    - WeakSet中只能存放对象类型，不能存放基本数据类型
    - WeakSet对元素的引用是弱引用，如果没有其他引用对某个对象进行引用，那么GC可以对该对象进行回收
  - WeakSet不能遍历: 因为WeakSet只是对对象的弱引用，如果我们遍历获取到其中的元素，那么有可能造成对象不能正常的销毁,所以存储到WeakSet中的对象是没办法获取的
* **Map :用于存储映射关系**
  - 对象也是用来存储映射关系的,它们的区别是
    - 对象存储映射关系只能用字符串,Symbol作为属性名(key)
    - Map可以将其他类型作为key,比如对象,会自动将对象转成字符串来作为key
  - 支持for of的遍历

* **WeakMap**
  - 与Map一样也是以键值对的形式存在的
  - 与Map的区别
    - WeakMap的key只能是对象，不接受其他的类型作为key
    - WeakMap的key的引用是弱引用，如果没有其他引用引用这个对象，那么GC可以回收该对象
  - WeakMap不能遍历



###### 弱引用和强引用

* 弱引用:  WeakMap 和 WeakSet 是我们在 JavaScript 使用弱引用唯一途径 , `将一个对象作为键添加`到WeakMap 或 WeakSet 中并不能防止这些对象被回收。 --- es12新增WeakRefs(给对象赋值一个弱引用)
* 强引用:  对象的引用在 JavaScript 中是强引用，也就是`将一个引用对象通过变量或常量保存`时，那么这个变量或常量就是强引用，这个对象就不会被回收 

```js
弱引用就是，旁边有个人B指着A牵的狗，说：嘿，那有条狗，B指向那条狗，但他们之间没有是指绑在一起的东西。
当A放开狗链，狗就会跑掉（被垃圾回收），无论B是不是还指着。
但是，当B不再指着那条狗，狗还被A牵着，不会影响它是否跑掉。
https://img.php.cn/upload/article/000/000/067/e4d2661e3554fec6a1413ff37522eef7-0.png
```



## 8. 异步

### 8.1 说说Promise的作用和使用方法（各个回调的作用）

首先，promise出现的原因？解决了什么问题？

```js
出现的原因：
在es5时代，如果我们要发送网络请求，一个网络请求中再嵌套另一个网络请求，每次都要等到上一层的网络请求拿到值后才能继续执行，如果有多个这样的函数回调，那么就会造成回调地狱，回调地狱会让代码的可读性非常差，非常难维护
解决的问题：
在es6时代，为了解决回调地狱的问题，出现了promise
1. 链式操作减低了编码难度 2. 代码可读性明显增强
```

* Promise 翻译为承若 是异步编程的一种解决方案
* Promise异步操作的优点 1. 链式操作减低了编码难度 2. 代码可读性明显增强
* Promise对象的状态不受外界影响 一旦确定,就不会再改变

```js
const promise = new Promise((resolve,reject) => {
    resolve("success");
    // reject("failure");
})
promise.then(res => {
    console.log(res)
}).catch(err => {
    console,log(err)
})
```



### 8.2 Promise的实例方法和类方法

实例方法 -- 存放在Promise的prototype上的

* then
* catch
* finally

类方法

* resolve -- Promise.resolve的用法相当于new Promise，并且执行resolve操作
* reject -- Promise.reject的用法相当于new Promise，只是会调用reject
* all -- Promise.all将多个Promise包裹在一起形成一个新的Promise

```js
//Promise.all将多个Promise包裹在一起形成一个新的Promise
//新的Promise状态由包裹的所有Promise共同决定
1.当所有的Promise状态变成fulfilled状态时，新的Promise状态为fulfilled，并且会将所有Promise的返回值组成一个数组；   
2.当有一个Promise状态为reject时，新的Promise状态为reject，并且会将第一个reject的返回值作为参数；
```

* allSettled

```js
// all有一个缺陷 -- 当其中有一个Promise的状态为rejected是,新的Promise就会变成对应的rejected状态
// 对于那些处于fulfilled,以及pending状态的Promise是获取不到的
// Promise.allSettled -- 会等所有Promise都有结果,并且无论fulfilled还是rejected状态,都会返回
// 并且这个Promise的结果一定是fulfilled的
```

* race [reɪs]

```js
// 无论是fulfilled还是rejected状态,谁先有结果,就使用谁得到结果
```

* any

```js
// any方法会等到第一个fulfilled状态，才会决定新Promise的状态
// 要是多有的Promise都是rejected状态,会报一个AggregateError的错误
// any promise err AggregateError: All promises were rejected
```



### 8.3 简单说下Promise.all和Promise.race区别和使用场景

##### 区别

promise.all中所有的子promise都会执行，当所有的子promise执行完成，该promise就完成，返回值是全部值的数组；如果有任何一个子promise失败，则该promise失败，返回值是第一个失败的子promise的结果

promise.race只会执行最快的子promise，有任意一个子promise成功返回后，就算完成，不论结果成功还是失败

##### 使用场景

promise.all：当一个页面需要多个模块的数据都返回回来时才能显示，否则一直加载

promise.race：一般用于和定时器绑定，将异步操作和定时器放在一起，如果定时器触发，就认为超时，告知用户



### 8.4 说说什么是异步函数？与普通函数有什么区别？

* 使用async关键字声明的函数都是异步函数
* 区别
  * 步函数内部代码的执行过程和普通函数一样,默认情况下会同步执行
  * 如果在异步函数中报了错,不会像普通函数那样报错,而是会将错误作为Promise的reject传递
  * 异步函数的返回值 - 相当于是包裹在Promise.resolve()中



### 8.5 ajax的原理是什么? 如何实现?

* **AJAX**全称(Async JavaScript and XML) -- 异步的JavaScript和XML
* **Ajax** 的原理简单来说通过 **XMLHttpRequest** 对象来向服务器发异步请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面

```js
// 1.创建XMLHttpRequest对象实例
const xhr = new XMLHttpRequest();

// 2.监听状态的改变(这是添加在宏任务中)
xhr.onreadystatechange = function () {
    console.log(xhr.response);
    // 在XMLHttpRequest的状态为3和4时,都会调用这里的函数,所以控制台打印了两次
    // 1和2还没有结果,所以什么也没有打印
};

// 3.配置请求: open
// methed: 请求方式(get/post/delete/patch...)
// url: 请求地址
xhr.open("get", "http://xx.xx.xxx.x");

// 4.发送请求: send --浏览器帮助发送对应的请求
xhr.send();
```

* 通过上面对 XMLHttpRequest 的了解 封装一个简单的ajax

```js
function ajax(options) {
    //创建XMLHttpRequest对象
    const xhr = new XMLHttpRequest()

    //初始化参数的内容
    options = options || {}
    options.type = (options.type || 'GET').toUpperCase()
    options.dataType = options.dataType || 'json'
    const params = options.data

    //发送请求
    if (options.type === 'GET') {
        xhr.open('GET', options.url + '?' + params, true)
        xhr.send(null)
    } else if (options.type === 'POST') {
        xhr.open('POST', options.url, true)
        xhr.send(params)

    //接收请求
    xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
            let status = xhr.status
            if (status >= 200 && status < 300) {
                options.success && options.success(xhr.responseText, xhr.responseXML)
            } else {
                options.fail && options.fail(status)
            }
        }
    }
}
```

```js
// 使用方法
ajax({
    type: 'post',
    dataType: 'json',
    data: {},
    url: 'https://xxxx',
    success: function(text,xml){//请求成功后的回调函数
        console.log(text)
    },
    fail: function(status){////请求失败后的回调函数
        console.log(status)
    }
})
```





## 9. Proxy

### 9.1 说说Object.defineProperty和Proxy的区别?

* Object.defineProperty的设计初衷是定义对象的属性,所以有些操作是监听不到的
  * 对于复杂的对象 层级很深的对象 需要深度监听
  * 属性的新增和删除是监听不到的
  * 不能监听数组的变化
* Proxy的设计初衷就是为了监听对象的改变 有13中方法监听对象的操作
* Vue全家桶 6.4



### 9.2 说说什么是Reflect? 为什么需要使用它?

- **Reflect** 是一个内置的对象 ,一个对象,不是函数,所以 它是不可构造的 
- 提供了很多操作JavaScript对象的方法，与Object中操作对象的方法相似,但存在细微的差异
- 有Object可以做这些操作，那么为什么还需要有Reflect这样的新增对象呢?
  - 因为在早期的ECMA规范中没有考虑到这种对 对象本身 的操作如何设计会更加规范
  - 以将这些API放到了Object上面,这使得Object过于臃肿
  - 但是Object作为一个构造函数，这些操作实际上放到它身上并不合适
  - 所以在ES6中新增了Reflect，让我们这些操作都集中到了Reflect对象上
  - 另外在使用Proxy时，可以做到不操作原对象
- 为什么要使用它?
  - 提供了多种方法方便我们统一管理对象,在对对象进行操作时有些方法会有返回值,操作对象变的更加规范
  - Object作为构造函数,操作对象的方法放在它身上不是很合适,早期的设计不规范导致的
  - 在使用Proxy监听对象时,使用Reflect避免了对原对象的直接操作





## 10. 迭代器和生成器

### 10.1 什么是迭代器?

* **迭代器(iterator): 就是让一些不支持遍历的数据结构支持遍历**

* 迭代器也是一个对象, 这个对象需要符合**迭代器协议**

* 要满足迭代器协议 ,就需要实现一个next()方法

  * 一个无参数或者一个参数的函数,返回一个拥有以下两个属性的对象

  ```js
  * done（boolean）
    *  如果迭代器可以产生序列中的下一个值，则为 false。
    *  如果迭代器已将序列迭代完毕，则为 true 
  * value
    * 迭代器返回的任何 JavaScript 值。done 为 true 时可省略
  ```

  ```js
  // 封装⼀个为数组创建迭代器的函数
  function createArrayIterator(arr) {
      let index = 0
      return {
      	next: function() {
          	if (index < arr.length) {
          		return { done: false, value: arr[index++] }
          	} else {
          		return { done: true }
          	}
          }
      }
  }
  ```

  



### 10.2 什么是迭代对象?

* 他和迭代器是不同的概念
* 当一个对象实现了**迭代器协议**时,它就是一个迭代器对象
* 这个对象的要求是必须实现 @@iterator 方法，在代码中我们使用 Symbol.iterator 访问该属性



### 10.3 什么是生成器? 生成器和迭代器有什么关系?

* **生成器(Generator)**:是一种一种函数控制、使用的方案可以让我们更加灵活的控制函数什么时候继续执行、暂停执行等
* 生成器函数也是一个函数,与普通函数有一些区别
  - 首先，生成器函数需要在function的后面加一个符号：*
  - 其次，生成器函数可以通过yield关键字来控制函数的执行流程
  - 最后，生成器函数的返回值是一个Generator（生成器）
    - **生成器事实上是一种特殊的迭代器**



## 11. 事件循环

### 11.1 说说什么是事件循环？

* 首先，javascript是单线程语言，单线程就使得同一时间只能做一件事
* 为了解决单线程运行阻塞的问题，JavaScript采用了一种机制，这种机制就叫做事件循环
* 在JavaScript中，所有的任务都被放在了事件循环队列中，而所有任务又可以分为两种，分别是同步任务和异步任务(事件任务队列是一个先进先出的队列，排在前面的事件会优先被主线程读取)
  * 同步任务就是立即执行的任务，会放到主线程中执行
  * 异步任务就是类似于网络请求和定时器的任务
  * 执行顺序为：**同步任务先进入主线程，也就是主执行栈，异步任务进入任务队列，当主线程内的任务执行完毕后，会去任务队列中读取对应的任务，将队列中的任务推入到主线程中执行。这个过程的不断重复就是事件循环**
* 异步任务还可以细分为微任务和宏任务
  * **在执行任何一个宏任务之前 ,必须保证微任务队列是空的**
  * 微任务: promise、MutaionObserver
  * 宏任务: ajax、setTimeout、setInterval、DOM监听等
* 整个事件循环的顺序：同步任务(全局代码) -> 微任务 -> 宏任务



### 11.2 说说你对事件队列、微任务、宏任务的理解

- **事件队列(先进先出)**
  - 事件队列是⼀种数据结构，可以存放要执⾏的任务。它符合**队列**“**先进先出**”的特点
- **微任务**
  - Promise的then回调、 Mutation Observer API、queueMicrotask()等
- **宏任务**
  - I/O操作（ajax/fetch/Node中的文件系统/网络请求/数据库交互）、setTimeout、setInterval、DOM监听、UI Rendering（UI渲染）等
- **在执行任何一个宏任务之前 ,必须保证微任务队列是空的**
- 事件队列中的任务会压入到执行栈中执行(当有异步代码时,会等异步的延时结束后,才会添加到事件队列中)



## 12. 网络HTTP

### 12.1 说说你对HTTP协议的理解，和HTTPS的区别？

http

* HyperText Transfer Protocol 超文本传输协议 
* 超文本传输协议是一种用于分布式协作式的应用层协议 
* 定义了客户端和服务器之间交换报文的格式和方式 默认为80端口 
* 使用tcp作为传输层协议 保证了数据的可靠性
* 在实际应用中，HTTP常被用于在Web浏览器和网站服务器之间传递信息，**以明文方式发送内容，不提供任何方式的数据加密**

一个http请求包括请求和响应

* 请求

  * 主要包含: 请求行 请求头 请求体

  ````js
  请求⾏
  * 请求⽅法字段
  * URL字段
  * HTTP协议版本字段
  * GET/index.html HTTP/1.1
  请求头
  * 键值对组成
  * User-Agent: 对应展示的浏览器的类型
  * Content-type: 对应的请求内容的数据类型
  	* application/x-www-form-urlencoded 数据以&分割 的键值对 键值对⽤=分割
  	* application/json json类型
  	* application/xml xml类型
  	* text/plain ⽂本类型
  	* multipart/form-data 表示上传⽂件
  * keep-alive
  请求体: get/post所带的内容
  ````

* 响应

  * 响应行 响应头 响应体

* 请求方法

  * get 向服务器获取数据 
  * post 将响应实体交给指定的资源 
  * head 请求⼀个与get请求响应相同的响应 没有实体 
  * put 上传⽂件 ⽤于替换⽬标资源的所有 
  * patch ⽤于对资源的部分修改 
  * delete 删除指定的资源 
  * connect: 建⽴⼀个到⽬标资源标识的服务器的隧道 通常⽤于代理服务器 
  * track: 回显服务器收到的请求 主要⽤于测试和诊断

* 响应状态码

  * 200 表示请求被服务器端正常处理 
  * 201 post请求 创建新的资源 
  * 301 永久重定向 表示资源被分配了新的URI 并返回该URI 
  * 4xx 表示客户端发⽣错误
    * 400 请求报⽂存在语法错误 
    * 401 未授权的错误 必须携带身份信息 
    * 403 没有权限访问 
    * 404 服务器找不到请求资源
  * 5xx 服务器错误 
    * 500 服务器内部错误：服务器遇到错误，无法完成请求
    * 503 服务器不可用（由于超载或停机维护）

##### 与HTTPS的区别?

`HTTP`传递信息是以明文的形式发送内容，这并不安全。而`HTTPS`出现正是为了解决`HTTP`不安全的特性

为了保证这些隐私数据能加密传输，让`HTTP`运行安全的`SSL/TLS`协议上，即 HTTPS = HTTP + SSL/TLS

通过 `SSL`证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密

* HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理，相对更安全
* HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443
* HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP
* HTTPS需要SSL，SSL 证书需要钱，功能越强大的证书费用越高



### 12.2 说说XMLHttpRequest和Fetch请求的异同

* Fetch API是`XMLHttpRequest`的替代方案
* Fetch的返回值是一个Promise
  - 请求成功时,调用resolve回调then
  - 请求失败时,调用reject回调catch
* 语法简单 更加语义化 
* 基于标准的promise实现 支持async/await
* 不像XMLHttpRequest一样，所有的操作都在一个对象上

Fetch缺点

* 不⽀持abort(超时取消请求) 不⽀持超时控制 
* 没有办法检测请求进度 XHR可以 
* 默认不会携带cookie

ajax的缺点

* 使⽤起来⽐较繁琐



### 12.3 如何取消请求的发送

* xhr

  * 如果使⽤ XMLHttpRequest 发送请求可以使⽤ XMLHttpRequest.abort() 

* fetch

  * 如果使⽤ fetch 发送请求可以使⽤ AbortController

  ```js
  const controller = new AbortController();
  const signal = controller.signal;
  fetch('https://somewhere', { signal })
  controller.abort()
  ```

* axios 

  * 如果使⽤ axios ，取消原理同 fetch

  ```js
  var CancelToken = axios.CancelToken;
  var source = CancelToken.source();
  axios.get('/https://somewhere', {
   cancelToken: source.token
  }
  source.cancel()
  ```

  

### 12.4 什么是跨域? 为什么会有跨域问题?

* 跨域是指**跨域名的访问**，以下情况都属于跨域
* **协议(HTTP/HTTPS), 域名, 端口必须完全相同**
* 域名不同 -- www.jd.com 与 www.taobao.com
  * 域名相同，端⼝不同 -- www.jd.com:8080 与 www.jd.com:8081
  * ⼆级域名不同 -- item.jd.com 与 miaosha.jd.com

早期服务端渲染的应用通常不会有跨域问题，因为前端代码和后端api都是在同一个服务器上运行的

随着前后端分离的出现，前后端的代码通常部署在不同的服务器上，这就引发了跨域问题

* **为什么有跨域问题?**

  * 是受浏览器同源策略的影响

  * 同源策略（Same-Origin Policy，SOP）是浏览器为了保障用户信息安全而实施的一种安全策略。

  * 跨域问题是浏览器对于ajax请求的一种安全限制：一个页面发起的ajax请求，只能是于当前页同域名的

    路径，这能有效的阻止跨站攻击。

* 因此：跨域问题 是针对ajax的⼀种限制



### 12.5 解决跨域

开发过程中常用的跨域解决方案

* CORS设置
  * 让后端在测试服务器上配置CORS（跨域资源共享）策略
  * 这通常涉及在厚度教案的响应头中添加 Access-Control-Allow-Origin
* 在vite/webpack中配置
  * 这些工具底层实现通常使用了http-proxy这个库，可以在本地开发环境中代理API请求到指定的后端服务，从而绕过浏览器的同源策略

目前线上常用的跨域解决方案有2种

* Nginx反向代理
  * 利⽤nginx反向代理把跨域为不跨域，⽀持各种请求方式 
  * 缺点：需要在nginx进⾏额外配置
* CORS规范化的跨域请求解决方案，安全可靠
  * 优势： 在服务端进行控制是否允许跨域，可自定义规则，⽀持各种请求方式
  * 缺点：CORS需要IE10+



### 12.6 解释正向代理和反向代理的概念，以及其在网络通信中的作用





### 12.7 什么是REST 用起来有什么好处?

* REST是⼀种软件架构模式（即API接⼝的设计模式），最常⽤的数据格式是JSON

* 由于JSON能直接被JavaScript读取，所以，以JSON格式编写的REST风格的API具有简单、易读、易用的 

  特点

* 通过REST模式设计的API可以把webapp全部功能进⾏封装，可以很容易的实现前后端分离，使的前端 

  代码易编写，后端代码易测试



## 13. 其他

### 13.1 说说async和defer的使用及区别?

**<script>标签的defer和async属性用来控制外部脚本文件的加载和执行方式，它们对于改善页面的加载速度非常有帮助**

浏览器在解析构建DOM树的过程中 如果遇到script元素会停止构建DOM树 先下载JavaScript代码 执行对应的脚本

如果JavaScript 代码过多 则浏览器处理的时间会过长 则会造成页面的阻塞

* 为什么在构建DOM数的过程中 遇到script元素会停止构建DOM树呢？
  * 因为如果我们等到DOM树构建完成并渲染再执行js代码，会造成严重的回流和重绘，影响页面性能

为了解决这个问题 出现了两个属性 async defer

* defer: 给 js 脚本添加 defer 属性
  * 脚本的下载会与DOM树的构建同时进行（如果defer脚本提前下载好了，他会等待DOM Tree构建完成，在DOMContentLoaded事件之前执行）
  * 同时多个defer属性的script标签 则会按照顺序执行
  * 推荐放到head标签中 可以早解析
* async: 给 js 脚本添加 async 属性
  * 脚本的下载会与DOM树的构建同时进行（如果async脚本下载好了，它会立即执行）
  * 所以多个async属性的脚本不保证运行顺序

在现代化的开发过程中，往往不需要我们自己来配置defer或者async

* 在使用脚手架或者自己搭建的webpack或vite项目进行打包时，他会根据需要帮我们加上defer属性
* 某些情况我们想要进行性能优化时，也可以手动加上async属性（例如一些第三方分析工具或者广告脚本，所以推荐放到body标签最后）

##### 补充: JavaScript 脚本延迟加载的方式有哪些

* 给 js 脚本添加 defer 属性
* 给 js 脚本添加 async 属性
* 动态创建 DOM 方式: 动态创建 DOM 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入js 脚本
* 使用 setTimeout 延迟方法
* 让 JS 最后加载：将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行



### 13.2 LocalStorage和SessionStorage的区别?

* LocalStorage提供一种永久性存储的方法 在网页关闭打开时 依然保留
* SessionStorage: 会话存储 再关闭该网页时 存储的内容被清除



### 13.3 说说new操作背后的原理?

* 在内存中创建一个新的空对象
* 构造函数的显示原型赋值给这个对象的隐式原型
* this会指向创建出来的新对象**（this的绑定在这个步骤完成）**
* 执行函数体中的代码
* 默认返回这个对象,(如果没有返回非空对象时)



### 13.4 说说你对防抖节流的理解 以及他们的使用场景

- **什么是防抖?**
  - 当我们频繁的触发一个事件时,每触发一次这个事件都会响应 - 1秒内触发100次?甚至1000次呢,这显然是很消耗性能的
  - 所以防抖就是 : 当事件触发时,相应的函数不会立马响应,而是会等一会儿，当事件密集触发时,对应的函数就会被频繁的推迟,只有当等待一会儿也没有事件触发,才会对函数进行响应
  - 防抖也可以做性能优化
  - 应用场景
    - 按钮的点击 
    - 屏幕滚动时的复杂计算 
    - 输入框输入时进行搜索 
    - 用户缩放浏览器的resize事件
- **什么是节流?**
  - 节流就是 : 当某个事件被频繁触发时,与防抖不同,节流会按照一定的频率来执行函数,不管中间触发了多少次,执行的频率总是固定的
  - 节流可以应用在 - 监听页面的滚动,一些游戏的实现(比如王者荣耀的普攻键,不会因为我们按普攻键很快而加快英雄的攻速)
  - 应用场景
    - 监听页面的滚动事件 通过节流来降低事件调⽤的频率 
    - 鼠标移动 
    - 用户频繁点击按钮的操作
  - 注意: 第一次会立即执行



### 13.5 什么是值传递? 什么是引用传递?

* 值类型(原始类型) -- 在变量中保存的是值本身,占据的空间是在栈内存中分配的
* 引用类型(对象类型) -- 在变量中保存的是对象的“引用”,占据的空间是在堆内存中分配的
* 值传递
  * 是将值类型传递给函数参数
* 引用传递
  * 是将引用类型传递给函数参数,函数参数保存的是对象的"引用"





### 13.6 说说对象的引用赋值 浅拷贝 深拷贝的区别

- 引用赋值 - 两个对象指向同一个地址
- 浅拷贝 - 只有第一层的对象会拷贝过去,更深层则是地址复制过去,不会生成新的对象,所以深层的对象也是指向同一个地址
- 深拷贝 - 可以拷贝更深层的对象 

浅拷贝和深拷贝都创建出一个新的对象，但在复制对象属性的时候，行为就不一样

- 浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址
- 深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址



### 13.7 如何实现浅拷贝 深拷贝?

```js
const obj = {
    name: "http",
    age: 19,
    friend: {
      name: "kobe",
    },
};

// 引用赋值 -- 修改info的属性,obj也会跟着改变(info,obj指向同意个对象)
const info = obj;

// 浅拷贝 -- 修改info的属性,obj不会跟着改变,(...obj)相当于是将obj里的属性赋值了一份给info2
//           因为是复制过去的,friend的地址和obj还是指向的同一个 --所以叫浅拷贝
//浅拷贝实现1 -- 利用展开运算符
const info2 = { ...obj };
info2.name = "大大怪将军";
console.log(obj.name); // http
//浅拷贝实现2 -- 通过Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的 __proto__
//const info4 = Object.create(obj);
//info4.friend.name = "关羽";
//console.log(obj.friend.name); //关羽
// 浅拷贝实现3 -- Object.assign [əˈsaɪn]
// const info5 = Object.assign({}, obj);
// info5.friend.name = "ERER";
// console.log(obj.friend.name); //ERER	

// 深拷贝 -- 
// 通过JSON转化后，新对象和之前的对象并不是同一个对象，即两个对象指向的内存地址不同
// 但是也有缺点 - json不会转化函数，如果碰到函数，会自动移除,undefined也不会
const info3 = JSON.parse(JSON.stringify(obj));
info3.friend.name = "小小怪下士";
console.log(obj.friend.name);
```

##### 深拷贝的实现思路：使用递归



### 13.8 说说服务端渲染后前后端分离的区别?

服务端渲染 SSR

* 优点
  * 更快的响应时间 首页加载更快
  * 更好的SEO
  * 无需占用客户端资源 解析模板交给后端工作 对于客户端的资源占用更少

* 缺点
  * 占用服务器资源 ⼀个小小的页面的改动 都需要请求⼀次完整的html页面
  * ⼀些常见的api需要先对运行环境判断再使用

前后端分离

* 优点
  * 用户体验更好
  * 前后端职责明确
* 缺点
  * 第⼀次响应内容较慢
  * 不利于SEO优化 只是记录一个页面 对于SEO较差



### 13.9 说说JavaScript中内存泄露的几种情况

* 什么是内存泄露
  * 是在计算机学科中, 由于疏忽或者错误造成程序未能释放自己已经不在使用的内存
  * 对于持续运行的程序, 如果没有及时释放不再使用到的内存, 内存会越来越高, 从而影响性能, 甚至崩溃
* 像 C / C++ 这种需要手动管理的内存, 内存泄露是经常出现的事情

**垃圾回收机制(GC)**

* JS具有自动垃圾回收机制，也就是说，执行环境会负责管理代码执行过程中使用的内存
* 原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存
* 通常情况下有两种实现方式：
  * 引用计数
  * 标记清除

**常见内存泄露情况**

* 意外的全局变量
* 另一种意外的全局变量可能由 `this` 创建
* 定时器也常会造成内存泄露 -- 定时器引用了外部元素
* 闭包, 为维持函数内局部变量，使其得不到释放 -- 设置为null

```js
function foo(){
    message = "112233"
}

function foo() {
    this.message = "aabbcc"
}

function foo() {
    var obj = document.createElement('XXX');
    var unused = function () {
      console.log(obj, '闭包内引用obj obj不会被释放');
    };
    obj = null; // 解决方法
}
```



### 13.10 Javascript本地存储的方式有哪些？区别及应用场景？

四种: cookie sessionStorage localStorage indexDB

indexDB

* 储存量理论上没有上限
* 所有操作都是异步的，相比 `LocalStorage` 同步操作性能更高，尤其是数据量较大时
* 原生支持储存`JS`的对象
* 是个正经的数据库，意味着数据库能干的事它都能干
* 操作非常繁琐 有一定门槛

**存储大小**

* cookie: 4kb左右
* localStorage 和sessionStorage ：5mb
* indexDB：理论上没有上限

**有效时间**

* cookie可设置失效时间，没有设置的话，默认是关闭浏览器后失效
* localStorage的数据在不手动清除的情况下，会永久保存
* sessionStorage仅在当前网页会话下有效，关闭页面或者浏览器的时候会被清除

**数据与服务器之间的交互方式**

* cookie 的数据会自动的传递到服务器，服务器端也可以写 cookie 到客户端
* localStorage 和sessionStorage 仅在客户端保存，不参与和服务器的通信

**应用场景**

* cookie用于存储用户名和密码
* 敏感账号一次性登录，推荐使用 sessionStorage
* 适合长期保存在本地的数据，推荐使用 localStorage 
* 存储大量数据的情况，推荐使用indexDB



### 13.11 setTimeout和setInterval的运行原理以及在运行原理层面讲解他们的区别

**介绍**

setTimeout和setInterval都是通过一个定时器控制回调函数的执行。

**原理**

由于js单线程的特点，两者都不能准确控制函数的执行时间。

这时候就涉及到了异步任务中的任务队列，定时器任务是存放到宏任务队列中的。

**区别**

按照数据结构队列先进先出的特性：这两种定时器都会加入到宏任务队列中，按照先后顺序等待线程空闲时执行，但两者都无法保证在何时执行回调，因为无法知道线程何时是空闲的。

两者之间的不同点是setTimout只会将函数添加到任务队列中一次，而setInterval则是循环往队列中添加函数

setTimeout可以保证函数在指定的时间间隔内不会执行

而setInterval不能保证，假设setInterval设置为100毫秒执行一次，执行的回调函数是一个复杂的函数，执行该函数需要90毫秒，那么下一次setInterval执行就是10毫秒之后，而不是我们希望的每100毫秒执行一次，因为setInterval只关注任务添加，不关注任务执行。由于这种机制，在很多情况下setInterval会有性能问题，对于复杂的情况，setInterval经常会出现执行间隔相差很大的情况，这样会带来不好的用户体验。

在实际开发过程中，通常会用setTimeout来模拟setInterval的效果，每次向队列添加任务都判断线程是否繁忙，等到线程空闲的时候向队列添加回调函数



### 13.12 箭头函数和普通函数的区别

**this指向**

- 普通函数的this指向取决于函数是如何别调用的
  - 直接调用时为全局对象
  - 方法调用时为调用该方法的对象
  - new调用时为新创建出的实例对象
  - call、apply、bind调用时为三种方法的第一个参数
- 箭头函数内部是没有this的，所以如果在箭头函数中调用this，那么这个this始终指向外部函数(上层函数)的值，也就是说箭头函数不会改变this的指向

**构造函数**

- 普通函数有prototype属性，且prototype属性拥有constructor指向构造函数，所以普通函数可以进行实例化
- 但箭头函数是没有prototype属性的，也就无法指向构造函数，所以箭头函数不能实例化

**arguments参数**

- 普通函数绑定arguments对象
- 箭头函数不绑定arguments对象，当箭头函数需要使用多个参数时，可以使用剩余参数

```js
1、箭头函数不能作为构造函数，不能new
2、箭头函数没有自己的this
3、箭头函数没有arguments对象
4、箭头函数没有原型对象
```



### 13.13 异步编程的实现方式

* 回调函数
  * 当多个回调函数嵌套的时候会造成回调函数地狱，不利于代码的可维护

* Promise
  * 利用Promise特性链式调用
  * 但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。

* generator(生成器)

* async/await
  * 是 generator 和 promise 实现的一个自动执行的语法糖



### 13.14 Promise有什么缺点

* promise一旦新建就会立即执行，无法中途取消
* 如果不设置回调函数，promise内部的错误就无法反映到外部
* 当处于pending状态时，无法得知当前处于哪一个状态，是刚刚开始还是刚刚结束



### 13.15 将列表数组转成树结构的方式

```js
const list = [
  {
    id: 1001,
    parentId: 0,
    name: "中国",
  },
  {
    id: 1002,
    parentId: 1001,
    name: "湖南",
  },
  {
    id: 1003,
    parentId: 1001,
    name: "广东",
  },
  {
    id: 1004,
    parentId: 1003,
    name: "广州市",
  },
  {
    id: 1005,
    parentId: 1003,
    name: "佛山市",
  },
  {
    id: 1006,
    parentId: 1002,
    name: "长沙市",
  },
  {
    id: 1007,
    parentId: 1002,
    name: "湘潭市",
  },
  {
    id: 1008,
    parentId: 1004,
    name: "天河区",
  },
  {
    id: 1009,
    parentId: 1005,
    name: "顺德区",
  },
];
```

```js
 {
     id: 1001,
     parentId: 0,
     name: '中国',
     children: [
         {
             id: 1002,
             parentId: 1001,
             name: '湖南',
             children: [
                {id: 1006, parentId: 1002, name: '长沙市'},
                {id: 1007, parentId: 1002, name: '湘潭市'}
            ]
         },
         {
             id: 1003,
             parentId: 1001,
             name: '广东',
             children: [
                 {
                     id: 1004,
                     parentId: 1003,
                     name: '广州市',
                     children: [{id: 1008, parentId: 1004, name: '天河区'}]
                 },
                 {
                     id: 1005,
                     parentId: 1003,
                     name: '佛山市',
                     children: [{id: 1009, parentId: 1005, name: '顺德区'}]
                 }
             ]
         }
     ]
 }
```



* 方式一

  * 思路: 这种父子关系的数组分为两类，找到子节点然后逐一放到父节点中
    * 第一类是没有父节点的数据 --- 就是最顶层的数据(中国)
    * 第二类是有父节点的数据
  * **首先找到数组中有父节点的元素**
    * const parent = data.find((node) => node.id === item.parentId);
    * 第二种方式就是下面的这种

  * 然后循环数组的每一项，判断这一项有没有父节点，没有就作为顶层根节点(res.push)，有父节点的话就把这一项放到父节点的children中

  ```js
  const listToTree = (data) => {
  
    let obj = {};
    data.map((item) => {
      obj[item.id] = item;
    });
    
    let res = [];
    data.map((item) => {
      // const parent = data.find((node) => node.id === item.parentId);
      const parent = obj[item.parentId]; //判断当前项有没有父元素
      console.log(parent);
      if (parent) {  // 当前项有父节点
        // 判断parent中有没有children 没有则创建 有就直接把item push到children里
        parent.children = parent.children || [];
        parent.children.push(item);
      } else { // 当前项没有父节点，是根元素 -> 顶层  
        res.push(item); // item是对象的引用，利用了对象中的地址引用
      }
    });
    return res;
  };
  
  listToTree(list)
  ```

  

### 13.16 jsonp原理

* 什么是jsonp?
  * 是JSON的一种”使用模式“，可用于解决主流浏览器的跨域数据访问的问题。
* 



### 13.17 判断一个对象是否为空

```js
let data = {};
let message = { address: "深圳" };

// 1.for...in
const isEmpty = (obj) => {
    for (let key in obj) {
      return false;
    }
    return true;
};
console.log(isEmpty(data)); // true
console.log(isEmpty(message)); // false

// 2.空对象对应的字符串为 "{}"
console.log(JSON.stringify(data) == "{}"); // true

// 3.Object.keys(data).length 通过判断对象自身有没有key 值来判断是否为空的
console.log(Object.keys(data).length); // 0
console.log(Object.keys(data).length == 0); // true

// 4.Object.values(data).length 通过判断对象是否有value值来判断是否为空对象
console.log(Object.values(data).length); // 0
console.log(Object.values(data).length == 0); // true
```



### 13.18 判断一个变量是否为数组

```js
arr instanceof Array
arr.constructor === Array
Array.isArray(arr)
Object.prototype.toString.call(arr) === '[object Array]'
```





## 14. JS运行原理

#### Global Object（GO）全局对象

* JavaScript引擎会在执行代码之前，会在堆内存中创建一个全局对象：Global Object（GO）

  * JavaScript引擎会在执行代码 这里基于浏览器
  * 该对象 所有的作用域（scope）都可以访问，在浏览器中这个对象就是window
  * 里面会包含Date、Array、String、Number、setTimeout、setInterval等等
  * 其中还有一个window属性指向自己

#### Execution Contexts（执行上下文）

* JavaScript引擎内部有一个执行上下文栈（Execution Context Stack，简称ECS），它是用于执行代码的调用栈
* 全局的代码块为了执行会构建一个 Global Execution Context（GEC）
  * GEC会 被放入到ECS中 执行
* GEC被放入到ECS中里面包含两部分内容
  * 在代码执行前，在parser转成AST的过程中，会将全局定义的变量、函数等加入到GlobalObject中，但是并不会赋值
    * 这个过程也称之为变量的**作用域提升**
  * 在代码执行过程中，对变量赋值，或者执行其他的函数

#### Variable Object（VO）变量对象

* 每一个执行上下文会关联一个VO，变量和函数声明会被添加到这个VO对象中
* **当全局代码被执行的时候，VO就是GO对象了**

#### Functional Execution Context（FEC）函数执行上下文

* 在执行的过程中执行到一个函数时，就会根据函数体创建一个函数执行上下文，并且压入到EC
  Stack中

#### Activation Object（AO）活跃对象

* 因为**每个执行上下文都会关联一个VO**，那么函数执行上下文关联的VO是什么呢？
  * 当进入一个函数执行上下文时，会创建一个AO对象
  * 这个AO对象会使用arguments作为初始化，并且初始值是传入的参数
  * 这个AO对象会作为执行上下文的VO来存放变量的初始化

```js
VO是一个执行上下文中的概念
在全局执行上下文中，VO = GO
在函数执行上下文中，VO = AO
```



#### Scope Chain（作用域和作用域链）

* 每个执行上下文都与一个作用域链相关联
  * 作用域链是一个对象列表，用于变量标识符的求值
  * 当进入一个执行上下文时，这个作用域链被创建，并且根据代码类型，添加一系列的对象



## 16. TS

### 16.1 ts的数据类型有那些?

* `typescript` 和 `javascript`几乎一样，拥有相同的数据类型，另外在`javascript`基础上提供了更加实用的类型供开发使用

  * number / string / null / undefined / boolean  / object对象类型
  * array / tuple(元组类型) / enum(枚举类型) / any(任意类型) / void / never

* **null 和 undefined**

  * 在 JavaScript 中，null 与 undefined 分别表示**“这里有值，但是个空值”** 和 **“这里没有值”**

  * 而在 TypeScript 中，null 与 undefined 类型都是 **有具体意义的类型**

  * 默认情况下`null`和`undefined`是所有类型的子类型， 就是说你可以把 `null`和 `undefined`赋值给 `number`类型的变量

  * 在没有开启 `strictNullChecks` 检查的情况下，会**被视作其他类型的子类型**，比如 string 类型会被认为包含了 null 与 undefined 类型

    ```typescript
    const tmp1: null = null;
    const tmp2: undefined = undefined;
    const tmp3: string = null; // 仅在关闭 strictNullChecks 时成立，下同
    const tmp4: string = undefined;
    ```

* **array**

  * 数组类型，跟`javascript`一致，通过`[]`进行包裹，有两种写法

    ```typescript
    const arr1: string[] = [];
    
    const arr2: Array<string> = [];
    ```

* **tuple(元组类型)**

  * 允许表示一个已知元素数量和类型的数组

    ```typescript
    let tupleArr:[number, string, boolean];
    tupleArr = [12, '34', true]; //ok
    typleArr = [12, '34'] // no ok
    ```

* enum(枚举类型)

  * enum类型是对JavaScript标准数据类型的一个补充，使用枚举类型可以为一组数值赋予友好的名字

    ```typescript
    enum Color {Red, Green, Blue}
    let c: Color = Color.Green;
    ```

* void

  * 用于标识方法返回值的类型，表示该方法没有返回值

    ```typescript
    function hello(): void {
        alert("Hello Runoob");
    }
    ```

* never

  * `never`是其他类型 （包括`null`和 `undefined`）的子类型，可以赋值给任何类型，代表从不会出现的值

    但是没有类型是 never 的子类型，这意味着声明 `never` 的变量只能被 `never` 类型所赋值。

  * `never` 类型一般用来指定那些总是会抛出异常、无限循环

    ```typescript
    let a:never;
    a = 123; // 错误的写法
    
    a = (() => { // 正确的写法
      throw new Error('错误');
    })()
    ```

    





## 17.  如何实现PC端扫码登录

#### 1. 整体流程

* **PC 端生成二维码**：
  - PC 端向服务器请求生成一个唯一的登录凭证（例如 `token` 或 `sessionId`），并将其编码为二维码。
  - 二维码内容通常是一个 URL，包含登录凭证和其他必要信息。
* **手机扫描二维码**：
  - 用户使用手机扫描二维码，解析出登录凭证。
  - 手机端将用户信息（如用户 ID）和登录凭证发送到服务器，确认登录。
* **服务器验证登录**：
  - 服务器验证登录凭证和用户信息，确认登录状态。
  - 服务器将登录状态同步到 PC 端。
* **PC 端完成登录**：
  - PC 端轮询或通过 WebSocket 从服务器获取登录状态。
  - 登录成功后，PC 端跳转到登录后的页面

#### 2. 技术细节

**2.1 PC 端生成二维码**

* **生成登录凭证**：
  - PC 端向服务器发送请求，生成一个唯一的登录凭证（例如 UUID）。
  - 服务器将登录凭证存储在缓存（如 Redis）中，并设置过期时间。
* **生成二维码**：
  - 使用二维码生成库（如 `qrcode`）将登录凭证编码为二维码。



**2.2 手机扫描二维码**

* **解析二维码**：

  - 手机扫描二维码后，解析出登录凭证（`token`）。

  - 示例二维码内容：

    ```js
    https://example.com/login?token=123e4567-e89b-12d3-a456-426614174000
    ```

* **确认登录**：

  - 手机端将用户信息（如用户 ID）和登录凭证发送到服务器。



**2.3 服务器验证登录**

* **验证登录凭证**：
  - 服务器根据 `token` 从缓存中查找对应的登录凭证。
  - 验证 `token` 是否有效（未过期且未被使用）。
  - 将用户 ID 与 `token` 绑定，标记为已登录。
* **同步登录状态**：
  - 服务器将登录状态存储在缓存中，供 PC 端查询。



**2.4 PC 端完成登录**

* **轮询 或 WebSocket**：

  - PC 端通过轮询或 WebSocket 从服务器获取登录状态。
    ```txt
    轮询方式是指客户端会每隔一段时间就主动给服务端发送一次二维码状态的查询请求。
    
    长轮询是指客户端主动给服务端发送二维码状态的查询请求，服务端会按情况对请求进行阻塞，直至二维码信息更新或超时。当客户端接收到返回结果后，若二维码仍未被扫描，则会继续发送查询请求，直至状态变化（已失效或已成功）
    
    Websocket是指前端在生成二维码后，会与后端建立连接，一旦后端发现二维码状态变化，可直接通过建立的连接主动推送信息给前端
    ```

* **跳转登录后页面**：

  - 当 PC 端检测到登录成功后，跳转到登录后的页面。

#### 3. 安全性考虑

登录凭证有效期

- 登录凭证（`token`）应设置较短的有效期（如 5 分钟），防止被恶意利用。

HTTPS 加密

- 所有通信应通过 HTTPS 加密，防止数据被窃取。

防止重放攻击

- 每个登录凭证只能使用一次，使用后立即失效。

用户确认

- 手机端在确认登录时，应提示用户确认操作，防止误操作。

```plaintext
PC 端                      服务器                      手机端
 |                          |                          |
 | -- 1. 请求生成二维码 ----> |                          |
 | <-- 2. 返回 token --------|                          |
 |                          |                          |
 | -- 3. 显示二维码 --------> |                          |
 |                          |                          |
 |                          | <-- 4. 扫描二维码 ------- |
 |                          | -- 5. 确认登录 ---------> |
 |                          | <-- 6. 返回登录成功 ------ |
 | -- 7. 轮询登录状态 ------> |                          |
 | <-- 8. 返回登录成功 ------ |                          |
 | -- 9. 跳转登录后页面 ----->|                          |
```



#### 4. 什么是长轮询

**长轮询（Long Polling）** 是一种客户端与服务器之间实现实时通信的技术。它是传统轮询的改进版本

* 传统轮询的问题
  * 在传统轮询中，客户端会定期向服务器发送请求（例如每隔几秒），询问是否有新数据。这种方式有以下缺点：
    * **资源浪费**：即使没有新数据，客户端也会不断发送请求，浪费带宽和服务器资源。
    * **延迟高**：如果轮询间隔较长，客户端获取新数据的延迟会很高；如果间隔较短，服务器压力会很大。

* 长轮询的工作原理
  * **客户端发送请求后，服务器会保持连接，直到有新数据或超时**
  * 具体流程
    * 客户端向服务器发送请求
    * 服务器收到请求后，检查是否有新数据
      * 如果有新数据，立即返回响应。
      * 如果没有新数据，服务器会保持连接，直到有新数据或超时（例如 30 秒）
    * 客户端收到响应后，立即发送下一个请求，重复上述过程
* 长轮询优点
  * **实时性更好**：相比传统轮询，长轮询可以更快地将新数据推送给客户端。
  * **减少无效请求**：服务器只在有新数据时才返回响应，减少了无效请求的数量。
  * **兼容性好**：长轮询基于 HTTP 协议，兼容性较好，不需要额外的协议支持。
* 长轮询缺点
  * **服务器资源占用**：服务器需要保持大量连接，可能会消耗较多资源。
  * **超时问题**：如果连接超时，客户端需要重新发起请求，可能会导致延迟。
  * **不适合高并发场景**：在用户量非常大的情况下，长轮询可能会导致服务器压力过大。

* 长轮询 vs WebSocket
  * 长轮询和 WebSocket 都可以实现实时通信，但它们的适用场景不同
  * **长轮询**：
    - 基于 HTTP 协议，兼容性好。
    - 适合低频更新的场景（如消息通知）。
    - 实现简单，但效率较低。
  * **WebSocket**：
    - 基于 TCP 协议，支持全双工通信。
    - 适合高频更新的场景（如实时聊天、游戏）。
    - 效率高，但实现复杂。
* 长轮询是一种简单且有效的实时通信技术，适合低频更新的场景。它的核心思想是服务器保持连接，直到有新数据或超时





